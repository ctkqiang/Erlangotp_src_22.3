/*
 *  Warning: Do not edit this file.
 *  Auto-generated by 'beam_makeops'.
 */

OpCase(allocate_heap_tIt):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  do {
    unsigned needed = tb(tmp_packed1&BEAM_WIDE_MASK) + 1;
    do {
      Uint need = Ib((tmp_packed1>>BEAM_WIDE_SHIFT)) + needed;
      if (ERTS_UNLIKELY(E - HTOP < need)) {
        do {
          //
          // Since a garbage collection is expensive anyway, we can afford
          // to save the instruction counter so that the correct function will
          // be pointed in the crash dump if the garbage collection fails
          // because of insufficient memory.
          //
          SWAPOUT;
          c_p->i = I;
        } while (0);
        PROCESS_MAIN_CHK_LOCKS(c_p);
        FCALLS -= erts_garbage_collect_nobump(c_p, need, reg, tb(BeamExtraData(I[0])), FCALLS);
        ERTS_VERIFY_UNUSED_TEMP_ALLOC(c_p);
        PROCESS_MAIN_CHK_LOCKS(c_p);
        SWAPIN;
      }
      HEAP_SPACE_VERIFIED(Ib((tmp_packed1>>BEAM_WIDE_SHIFT)));
    } while (0);
    E -= needed;
    *E = make_cp(c_p->cp);
    c_p->cp = 0;
  } while (0);
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(allocate_heap_zero_tIt):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  Eterm* ptr;
  int i = tb(tmp_packed1&BEAM_WIDE_MASK);
  do {
    unsigned needed = i + 1;
    do {
      Uint need = Ib((tmp_packed1>>BEAM_WIDE_SHIFT)) + needed;
      if (ERTS_UNLIKELY(E - HTOP < need)) {
        do {
          //
          // Since a garbage collection is expensive anyway, we can afford
          // to save the instruction counter so that the correct function will
          // be pointed in the crash dump if the garbage collection fails
          // because of insufficient memory.
          //
          SWAPOUT;
          c_p->i = I;
        } while (0);
        PROCESS_MAIN_CHK_LOCKS(c_p);
        FCALLS -= erts_garbage_collect_nobump(c_p, need, reg, tb(BeamExtraData(I[0])), FCALLS);
        ERTS_VERIFY_UNUSED_TEMP_ALLOC(c_p);
        PROCESS_MAIN_CHK_LOCKS(c_p);
        SWAPIN;
      }
      HEAP_SPACE_VERIFIED(Ib((tmp_packed1>>BEAM_WIDE_SHIFT)));
    } while (0);
    E -= needed;
    *E = make_cp(c_p->cp);
    c_p->cp = 0;
  } while (0);
  for (ptr = E + i; ptr > E; ptr--) {
    make_blank(*ptr);
  }
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(allocate_init_tty):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  do {
    unsigned needed = tb(tmp_packed1&BEAM_TIGHT_MASK) + 1;
    do {
      Uint need = 0 + needed;
      if (ERTS_UNLIKELY(E - HTOP < need)) {
        do {
          //
          // Since a garbage collection is expensive anyway, we can afford
          // to save the instruction counter so that the correct function will
          // be pointed in the crash dump if the garbage collection fails
          // because of insufficient memory.
          //
          SWAPOUT;
          c_p->i = I;
        } while (0);
        PROCESS_MAIN_CHK_LOCKS(c_p);
        FCALLS -= erts_garbage_collect_nobump(c_p, need, reg, tb((tmp_packed1>>BEAM_TIGHT_SHIFT)&BEAM_TIGHT_MASK), FCALLS);
        ERTS_VERIFY_UNUSED_TEMP_ALLOC(c_p);
        PROCESS_MAIN_CHK_LOCKS(c_p);
        SWAPIN;
      }
      HEAP_SPACE_VERIFIED(0);
    } while (0);
    E -= needed;
    *E = make_cp(c_p->cp);
    c_p->cp = 0;
  } while (0);
  make_blank(yb((tmp_packed1>>(2*BEAM_TIGHT_SHIFT))));
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(allocate_tt):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  do {
    unsigned needed = tb(tmp_packed1&BEAM_TIGHT_MASK) + 1;
    do {
      Uint need = 0 + needed;
      if (ERTS_UNLIKELY(E - HTOP < need)) {
        do {
          //
          // Since a garbage collection is expensive anyway, we can afford
          // to save the instruction counter so that the correct function will
          // be pointed in the crash dump if the garbage collection fails
          // because of insufficient memory.
          //
          SWAPOUT;
          c_p->i = I;
        } while (0);
        PROCESS_MAIN_CHK_LOCKS(c_p);
        FCALLS -= erts_garbage_collect_nobump(c_p, need, reg, tb((tmp_packed1>>BEAM_TIGHT_SHIFT)), FCALLS);
        ERTS_VERIFY_UNUSED_TEMP_ALLOC(c_p);
        PROCESS_MAIN_CHK_LOCKS(c_p);
        SWAPIN;
      }
      HEAP_SPACE_VERIFIED(0);
    } while (0);
    E -= needed;
    *E = make_cp(c_p->cp);
    c_p->cp = 0;
  } while (0);
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(allocate_zero_tt):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  Eterm* ptr;
  int i = tb(tmp_packed1&BEAM_TIGHT_MASK);
  do {
    unsigned needed = i + 1;
    do {
      Uint need = 0 + needed;
      if (ERTS_UNLIKELY(E - HTOP < need)) {
        do {
          //
          // Since a garbage collection is expensive anyway, we can afford
          // to save the instruction counter so that the correct function will
          // be pointed in the crash dump if the garbage collection fails
          // because of insufficient memory.
          //
          SWAPOUT;
          c_p->i = I;
        } while (0);
        PROCESS_MAIN_CHK_LOCKS(c_p);
        FCALLS -= erts_garbage_collect_nobump(c_p, need, reg, tb((tmp_packed1>>BEAM_TIGHT_SHIFT)), FCALLS);
        ERTS_VERIFY_UNUSED_TEMP_ALLOC(c_p);
        PROCESS_MAIN_CHK_LOCKS(c_p);
        SWAPIN;
      }
      HEAP_SPACE_VERIFIED(0);
    } while (0);
    E -= needed;
    *E = make_cp(c_p->cp);
    c_p->cp = 0;
  } while (0);
  for (ptr = E + i; ptr > E; ptr--) {
    make_blank(*ptr);
  }
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(apply_last_tQ):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  BeamInstr *next;
  HEAVY_SWAPOUT;
  next = fixed_apply(c_p, reg, tb(tmp_packed1&BEAM_TIGHT_MASK), I, Qb((tmp_packed1>>BEAM_TIGHT_SHIFT)));
  HEAVY_SWAPIN;;
  if (ERTS_LIKELY(next != NULL)) {
    SET_CP(c_p, (BeamInstr *) cp_val(*E));
    E = ADD_BYTE_OFFSET(E, Qb((tmp_packed1>>BEAM_TIGHT_SHIFT)));;
    SET_I((BeamInstr *) next);
    DTRACE_LOCAL_CALL(c_p, erts_code_to_codemfa(I));
    Dispatch();;
  }
  I = handle_error(c_p, I, reg, &bif_export[BIF_apply_3]->info.mfa);
  goto post_error_handling;;
}

OpCase(apply_t):
{
  BeamInstr *next;
  HEAVY_SWAPOUT;
  next = fixed_apply(c_p, reg, tb(BeamExtraData(I[0])), NULL, 0);
  HEAVY_SWAPIN;;
  if (ERTS_LIKELY(next != NULL)) {
    SET_CP(c_p, I+1);
    SET_I((BeamInstr *) next);
    DTRACE_LOCAL_CALL(c_p, erts_code_to_codemfa(I));
    Dispatch();;
  }
  I = handle_error(c_p, I, reg, &bif_export[BIF_apply_3]->info.mfa);
  goto post_error_handling;;
}

OpCase(build_stacktrace):
{
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  SWAPOUT;
  x(0) = build_stacktrace(c_p, x(0));
  SWAPIN;
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(call_bif_e):
{
  ErtsBifFunc bf;
  Eterm result;
  ErlHeapFragment *live_hf_end;
  Export *export = (Export*) I[1];

  if (!((FCALLS - 1) > 0 || (FCALLS-1) > neg_o_reds)) {
    /*
    * If we have run out of reductions, do a context
    * switch before calling the BIF.
    */
    c_p->arity = GET_BIF_ARITY(export);
    c_p->current = &export->info.mfa;
    goto context_switch3;
  }

  ERTS_MSACC_SET_BIF_STATE_CACHED_X(GET_BIF_MODULE(export),
  GET_BIF_ADDRESS(export));

  bf = GET_BIF_ADDRESS(export);

  PRE_BIF_SWAPOUT(c_p);
  ERTS_DBG_CHK_REDS(c_p, FCALLS);
  c_p->fcalls = FCALLS - 1;
  if (FCALLS <= 0) {
    save_calls(c_p, export);
  }
  ASSERT(!ERTS_PROC_IS_EXITING(c_p));
  ERTS_VERIFY_UNUSED_TEMP_ALLOC(c_p);
  live_hf_end = c_p->mbuf;
  ERTS_CHK_MBUF_SZ(c_p);
  result = (*bf)(c_p, reg, I);
  ERTS_CHK_MBUF_SZ(c_p);
  ASSERT(!ERTS_PROC_IS_EXITING(c_p) || is_non_value(result));
  ERTS_VERIFY_UNUSED_TEMP_ALLOC(c_p);
  ERTS_HOLE_CHECK(c_p);
  ERTS_REQ_PROC_MAIN_LOCK(c_p);
  if (ERTS_IS_GC_DESIRED(c_p)) {
    Uint arity = GET_BIF_ARITY(export);
    result = erts_gc_after_bif_call_lhf(c_p, live_hf_end, result,
    reg, arity);
    E = c_p->stop;
  }
  PROCESS_MAIN_CHK_LOCKS(c_p);
  HTOP = HEAP_TOP(c_p);
  FCALLS = c_p->fcalls;
  ERTS_DBG_CHK_REDS(c_p, FCALLS);

  /*
  * We have to update the cache if we are enabled in order
  * to make sure no bookkeeping is done after we disabled
  * msacc. We don't always do this as it is quite expensive.
  */
  if (ERTS_MSACC_IS_ENABLED_CACHED_X()) {
    ERTS_MSACC_UPDATE_CACHE_X();
  }
  ERTS_MSACC_SET_STATE_CACHED_M_X(ERTS_MSACC_STATE_EMULATOR);
  if (ERTS_LIKELY(is_value(result))) {
    r(0) = result;
    CHECK_TERM(r(0));
    SET_I((BeamInstr *) I+2);
    Goto(*I);;
  } else if (c_p->freason == TRAP) {
    /*
    * Set the continuation pointer to return to next
    * instruction after the trap (either by a return from
    * erlang code or by nif_bif.epilogue() when the BIF
    * is done).
    */
    SET_CP(c_p, I+2);
    SET_I(c_p->i);
    SWAPIN;
    Dispatch();
  }

  /*
  * Error handling.  SWAPOUT is not needed because it was done above.
  */
  ASSERT(c_p->stop == E);
  I = handle_error(c_p, I, reg, &export->info.mfa);
  goto post_error_handling;

}

OpCase(call_bif_only_e):
{
  ErtsBifFunc bf;
  Eterm result;
  ErlHeapFragment *live_hf_end;
  Export *export = (Export*) I[1];

  if (!((FCALLS - 1) > 0 || (FCALLS-1) > neg_o_reds)) {
    /*
    * If we have run out of reductions, do a context
    * switch before calling the BIF.
    */
    c_p->arity = GET_BIF_ARITY(export);
    c_p->current = &export->info.mfa;
    goto context_switch3;
  }

  ERTS_MSACC_SET_BIF_STATE_CACHED_X(GET_BIF_MODULE(export),
  GET_BIF_ADDRESS(export));

  bf = GET_BIF_ADDRESS(export);

  PRE_BIF_SWAPOUT(c_p);
  ERTS_DBG_CHK_REDS(c_p, FCALLS);
  c_p->fcalls = FCALLS - 1;
  if (FCALLS <= 0) {
    save_calls(c_p, export);
  }
  ASSERT(!ERTS_PROC_IS_EXITING(c_p));
  ERTS_VERIFY_UNUSED_TEMP_ALLOC(c_p);
  live_hf_end = c_p->mbuf;
  ERTS_CHK_MBUF_SZ(c_p);
  result = (*bf)(c_p, reg, I);
  ERTS_CHK_MBUF_SZ(c_p);
  ASSERT(!ERTS_PROC_IS_EXITING(c_p) || is_non_value(result));
  ERTS_VERIFY_UNUSED_TEMP_ALLOC(c_p);
  ERTS_HOLE_CHECK(c_p);
  ERTS_REQ_PROC_MAIN_LOCK(c_p);
  if (ERTS_IS_GC_DESIRED(c_p)) {
    Uint arity = GET_BIF_ARITY(export);
    result = erts_gc_after_bif_call_lhf(c_p, live_hf_end, result,
    reg, arity);
    E = c_p->stop;
  }
  PROCESS_MAIN_CHK_LOCKS(c_p);
  HTOP = HEAP_TOP(c_p);
  FCALLS = c_p->fcalls;
  ERTS_DBG_CHK_REDS(c_p, FCALLS);

  /*
  * We have to update the cache if we are enabled in order
  * to make sure no bookkeeping is done after we disabled
  * msacc. We don't always do this as it is quite expensive.
  */
  if (ERTS_MSACC_IS_ENABLED_CACHED_X()) {
    ERTS_MSACC_UPDATE_CACHE_X();
  }
  ERTS_MSACC_SET_STATE_CACHED_M_X(ERTS_MSACC_STATE_EMULATOR);
  if (ERTS_LIKELY(is_value(result))) {
    /*
    * Success. Store the result and return to the caller.
    */
    r(0) = result;
    CHECK_TERM(r(0));
    SET_I(c_p->cp);
    DTRACE_RETURN_FROM_PC(c_p);

    /*
    * We must clear the CP to make sure that a stale value do not
    * create a false module dependcy preventing code upgrading.
    * It also means that we can use the CP in stack backtraces.
    */
    c_p->cp = 0;
    CHECK_TERM(r(0));
    HEAP_SPACE_VERIFIED(0);
    DispatchReturn;;
  } else if (c_p->freason == TRAP) {
    /*
    * Dispatch to a trap. When the trap is done, a jump
    * to the continuation pointer (c_p->cp) will be done.
    */
    SET_I(c_p->i);
    SWAPIN;
    Dispatch();
  }

  /*
  * Error handling.  SWAPOUT is not needed because it was done above.
  */
  ASSERT(c_p->stop == E);
  I = handle_error(c_p, I, reg, &export->info.mfa);
  goto post_error_handling;

}

OpCase(catch_end_y):
{
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  c_p->catches--;
  make_blank(yb(BeamExtraData(I[0])));;
  if (is_non_value(r(0))) {
    c_p->fvalue = NIL;
    if (x(1) == am_throw) {
      r(0) = x(2);
    } else {
      if (x(1) == am_error) {
        SWAPOUT;
        x(2) = add_stacktrace(c_p, x(2), x(3));
        SWAPIN;
      }
      /* only x(2) is included in the rootset here */
      if (E - HTOP < 3) {
        do {
          //
          // Since a garbage collection is expensive anyway, we can afford
          // to save the instruction counter so that the correct function will
          // be pointed in the crash dump if the garbage collection fails
          // because of insufficient memory.
          //
          SWAPOUT;
          c_p->i = I;
        } while (0);
        PROCESS_MAIN_CHK_LOCKS(c_p);
        FCALLS -= erts_garbage_collect_nobump(c_p, 3, reg+2, 1, FCALLS);
        ERTS_VERIFY_UNUSED_TEMP_ALLOC(c_p);
        PROCESS_MAIN_CHK_LOCKS(c_p);
        SWAPIN;
      }
      r(0) = TUPLE2(HTOP, am_EXIT, x(2));
      HTOP += 3;
    }
  }
  CHECK_TERM(r(0));
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(catch_yf):
{
  BeamInstr next_pf = BeamCodeAddr(I[3]);
  c_p->catches++;
  yb(I[1]) = I[2];
  I += 3;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(deallocate_Q):
{
  SET_CP(c_p, (BeamInstr *) cp_val(*E));
  E = ADD_BYTE_OFFSET(E, Qb(BeamExtraData(I[0])));
  I += 1;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(deallocate_return_Q):
{
  int words_to_pop = Qb(BeamExtraData(I[0]));
  SET_I((BeamInstr *) cp_val(*E));
  E = ADD_BYTE_OFFSET(E, words_to_pop);
  CHECK_TERM(x(0));
  DispatchReturn;
}

OpCase(get_hd_xx):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  Eterm* tmp_ptr = list_val(xb(tmp_packed1&BEAM_TIGHT_MASK));
  xb((tmp_packed1>>BEAM_TIGHT_SHIFT)) = CAR(tmp_ptr);
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(get_hd_xy):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  Eterm* tmp_ptr = list_val(xb(tmp_packed1&BEAM_TIGHT_MASK));
  yb((tmp_packed1>>BEAM_TIGHT_SHIFT)) = CAR(tmp_ptr);
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(get_hd_yx):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  Eterm* tmp_ptr = list_val(yb(tmp_packed1&BEAM_TIGHT_MASK));
  xb((tmp_packed1>>BEAM_TIGHT_SHIFT)) = CAR(tmp_ptr);
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(get_hd_yy):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  Eterm* tmp_ptr = list_val(yb(tmp_packed1&BEAM_TIGHT_MASK));
  yb((tmp_packed1>>BEAM_TIGHT_SHIFT)) = CAR(tmp_ptr);
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(get_list_rry):
{
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  Eterm* tmp_ptr = list_val(r(0));
  Eterm hd, tl;
  hd = CAR(tmp_ptr);
  tl = CDR(tmp_ptr);
  r(0) = hd;
  yb(BeamExtraData(I[0])) = tl;
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(get_list_rxr):
{
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  Eterm* tmp_ptr = list_val(r(0));
  Eterm hd, tl;
  hd = CAR(tmp_ptr);
  tl = CDR(tmp_ptr);
  xb(BeamExtraData(I[0])) = hd;
  r(0) = tl;
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(get_list_rxx):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  Eterm* tmp_ptr = list_val(r(0));
  Eterm hd, tl;
  hd = CAR(tmp_ptr);
  tl = CDR(tmp_ptr);
  xb(tmp_packed1&BEAM_TIGHT_MASK) = hd;
  xb((tmp_packed1>>BEAM_TIGHT_SHIFT)) = tl;
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(get_list_rxy):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  Eterm* tmp_ptr = list_val(r(0));
  Eterm hd, tl;
  hd = CAR(tmp_ptr);
  tl = CDR(tmp_ptr);
  xb(tmp_packed1&BEAM_TIGHT_MASK) = hd;
  yb((tmp_packed1>>BEAM_TIGHT_SHIFT)) = tl;
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(get_list_ryr):
{
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  Eterm* tmp_ptr = list_val(r(0));
  Eterm hd, tl;
  hd = CAR(tmp_ptr);
  tl = CDR(tmp_ptr);
  yb(BeamExtraData(I[0])) = hd;
  r(0) = tl;
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(get_list_xrx):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  Eterm* tmp_ptr = list_val(xb(tmp_packed1&BEAM_TIGHT_MASK));
  Eterm hd, tl;
  hd = CAR(tmp_ptr);
  tl = CDR(tmp_ptr);
  r(0) = hd;
  xb((tmp_packed1>>BEAM_TIGHT_SHIFT)) = tl;
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(get_list_xxx):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  Eterm* tmp_ptr = list_val(x(tmp_packed1&BEAM_TIGHTEST_MASK));
  Eterm hd, tl;
  hd = CAR(tmp_ptr);
  tl = CDR(tmp_ptr);
  x((tmp_packed1>>BEAM_TIGHTEST_SHIFT)&BEAM_TIGHTEST_MASK) = hd;
  x((tmp_packed1>>(2*BEAM_TIGHTEST_SHIFT))) = tl;
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(get_list_xxy):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  Eterm* tmp_ptr = list_val(x(tmp_packed1&BEAM_TIGHTEST_MASK));
  Eterm hd, tl;
  hd = CAR(tmp_ptr);
  tl = CDR(tmp_ptr);
  x((tmp_packed1>>BEAM_TIGHTEST_SHIFT)&BEAM_TIGHTEST_MASK) = hd;
  y((tmp_packed1>>(2*BEAM_TIGHTEST_SHIFT))) = tl;
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(get_list_xyx):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  Eterm* tmp_ptr = list_val(x(tmp_packed1&BEAM_TIGHTEST_MASK));
  Eterm hd, tl;
  hd = CAR(tmp_ptr);
  tl = CDR(tmp_ptr);
  y((tmp_packed1>>BEAM_TIGHTEST_SHIFT)&BEAM_TIGHTEST_MASK) = hd;
  x((tmp_packed1>>(2*BEAM_TIGHTEST_SHIFT))) = tl;
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(get_list_xyy):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  Eterm* tmp_ptr = list_val(x(tmp_packed1&BEAM_TIGHTEST_MASK));
  Eterm hd, tl;
  hd = CAR(tmp_ptr);
  tl = CDR(tmp_ptr);
  y((tmp_packed1>>BEAM_TIGHTEST_SHIFT)&BEAM_TIGHTEST_MASK) = hd;
  y((tmp_packed1>>(2*BEAM_TIGHTEST_SHIFT))) = tl;
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(get_list_yxx):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  Eterm* tmp_ptr = list_val(y(tmp_packed1&BEAM_TIGHTEST_MASK));
  Eterm hd, tl;
  hd = CAR(tmp_ptr);
  tl = CDR(tmp_ptr);
  x((tmp_packed1>>BEAM_TIGHTEST_SHIFT)&BEAM_TIGHTEST_MASK) = hd;
  x((tmp_packed1>>(2*BEAM_TIGHTEST_SHIFT))) = tl;
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(get_list_yxy):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  Eterm* tmp_ptr = list_val(y(tmp_packed1&BEAM_TIGHTEST_MASK));
  Eterm hd, tl;
  hd = CAR(tmp_ptr);
  tl = CDR(tmp_ptr);
  x((tmp_packed1>>BEAM_TIGHTEST_SHIFT)&BEAM_TIGHTEST_MASK) = hd;
  y((tmp_packed1>>(2*BEAM_TIGHTEST_SHIFT))) = tl;
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(get_list_yyx):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  Eterm* tmp_ptr = list_val(y(tmp_packed1&BEAM_TIGHTEST_MASK));
  Eterm hd, tl;
  hd = CAR(tmp_ptr);
  tl = CDR(tmp_ptr);
  y((tmp_packed1>>BEAM_TIGHTEST_SHIFT)&BEAM_TIGHTEST_MASK) = hd;
  x((tmp_packed1>>(2*BEAM_TIGHTEST_SHIFT))) = tl;
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(get_list_yyy):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  Eterm* tmp_ptr = list_val(y(tmp_packed1&BEAM_TIGHTEST_MASK));
  Eterm hd, tl;
  hd = CAR(tmp_ptr);
  tl = CDR(tmp_ptr);
  y((tmp_packed1>>BEAM_TIGHTEST_SHIFT)&BEAM_TIGHTEST_MASK) = hd;
  y((tmp_packed1>>(2*BEAM_TIGHTEST_SHIFT))) = tl;
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(get_tl_xx):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  Eterm* tmp_ptr = list_val(xb(tmp_packed1&BEAM_TIGHT_MASK));
  xb((tmp_packed1>>BEAM_TIGHT_SHIFT)) = CDR(tmp_ptr);
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(get_tl_xy):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  Eterm* tmp_ptr = list_val(xb(tmp_packed1&BEAM_TIGHT_MASK));
  yb((tmp_packed1>>BEAM_TIGHT_SHIFT)) = CDR(tmp_ptr);
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(get_tl_yx):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  Eterm* tmp_ptr = list_val(yb(tmp_packed1&BEAM_TIGHT_MASK));
  xb((tmp_packed1>>BEAM_TIGHT_SHIFT)) = CDR(tmp_ptr);
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(get_tl_yy):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  Eterm* tmp_ptr = list_val(yb(tmp_packed1&BEAM_TIGHT_MASK));
  yb((tmp_packed1>>BEAM_TIGHT_SHIFT)) = CDR(tmp_ptr);
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

{
  OpCase(hipe_trap_call):
  {
    /*
    * I[-5]: &&lb_i_func_info_IaaI
    * I[-4]: Native code callee (inserted by HiPE)
    * I[-3]: Module (tagged atom)
    * I[-2]: Function (tagged atom)
    * I[-1]: Arity (untagged integer)
    * I[ 0]: &&lb_hipe_trap_call
    * ... remainder of original BEAM code
    */
    ErtsCodeInfo *ci = erts_code_to_codeinfo(I);
    ASSERT(IsOpCode(ci->op, i_func_info_IaaI));
    c_p->hipe.u.ncallee = ci->u.ncallee;
    ++hipe_trap_count;
    SWAPOUT;
    ERTS_DBG_CHK_REDS(c_p, FCALLS);
    c_p->fcalls = FCALLS;
    c_p->def_arg_reg[4] = -neg_o_reds;
    c_p = hipe_mode_switch(c_p, HIPE_MODE_SWITCH_CMD_CALL | (ci->mfa.arity << 8), reg);;
  }
  goto hipe_trap__post;

  OpCase(hipe_trap_call_closure):
  {
    ErtsCodeInfo *ci = erts_code_to_codeinfo(I);
    ASSERT(IsOpCode(ci->op, i_func_info_IaaI));
    c_p->hipe.u.ncallee = ci->u.ncallee;
    ++hipe_trap_count;
    SWAPOUT;
    ERTS_DBG_CHK_REDS(c_p, FCALLS);
    c_p->fcalls = FCALLS;
    c_p->def_arg_reg[4] = -neg_o_reds;
    c_p = hipe_mode_switch(c_p, HIPE_MODE_SWITCH_CMD_CALL_CLOSURE | (ci->mfa.arity << 8), reg);;
  }
  goto hipe_trap__post;

  OpCase(hipe_trap_resume):
  {
    SWAPOUT;
    ERTS_DBG_CHK_REDS(c_p, FCALLS);
    c_p->fcalls = FCALLS;
    c_p->def_arg_reg[4] = -neg_o_reds;
    c_p = hipe_mode_switch(c_p, HIPE_MODE_SWITCH_CMD_RESUME, reg);;
  }
  goto hipe_trap__post;

  OpCase(hipe_trap_return):
  {
    SWAPOUT;
    ERTS_DBG_CHK_REDS(c_p, FCALLS);
    c_p->fcalls = FCALLS;
    c_p->def_arg_reg[4] = -neg_o_reds;
    c_p = hipe_mode_switch(c_p, HIPE_MODE_SWITCH_CMD_RETURN, reg);;
  }
  goto hipe_trap__post;

  OpCase(hipe_trap_throw):
  {
    SWAPOUT;
    ERTS_DBG_CHK_REDS(c_p, FCALLS);
    c_p->fcalls = FCALLS;
    c_p->def_arg_reg[4] = -neg_o_reds;
    c_p = hipe_mode_switch(c_p, HIPE_MODE_SWITCH_CMD_THROW, reg);;
  }
  goto hipe_trap__post;

  hipe_trap__post:
  {
#ifdef DEBUG
    pid = c_p->common.id; /* may have switched process... */
#endif
    reg = erts_proc_sched_data(c_p)->x_reg_array;
    freg = erts_proc_sched_data(c_p)->f_reg_array;
    ERL_BITS_RELOAD_STATEP(c_p);
    /* XXX: this abuse of def_arg_reg[] is horrid! */
    neg_o_reds = -c_p->def_arg_reg[4];
    FCALLS = c_p->fcalls;
    SWAPIN;
    ERTS_DBG_CHK_REDS(c_p, FCALLS);
    switch( c_p->def_arg_reg[3] ) {
      case HIPE_MODE_SWITCH_RES_RETURN:
      ASSERT(is_value(reg[0]));
      SET_I(c_p->cp);
      c_p->cp = 0;
      Goto(*I);
      case HIPE_MODE_SWITCH_RES_CALL_EXPORTED:
      c_p->i = c_p->hipe.u.callee_exp->addressv[erts_active_code_ix()];
      /*fall through*/
      case HIPE_MODE_SWITCH_RES_CALL_BEAM:
      SET_I(c_p->i);
      Dispatch();
      case HIPE_MODE_SWITCH_RES_CALL_CLOSURE:
      /* This can be used to call any function value, but currently
      it's only used to call closures referring to unloaded
      modules. */
      {
        BeamInstr *next;

        next = call_fun(c_p, c_p->arity - 1, reg, THE_NON_VALUE);
        HEAVY_SWAPIN;
        if (next != NULL) {
          SET_I(next);
          Dispatchfun();
        }
        goto find_func_info;
      }
      case HIPE_MODE_SWITCH_RES_THROW:
      c_p->cp = NULL;
      I = handle_error(c_p, I, reg, NULL);
      goto post_error_handling;
      default:
      erts_exit(ERTS_ERROR_EXIT, "hipe_mode_switch: result %u\n", c_p->def_arg_reg[3]);
    }

  }

}

OpCase(hot_is_function2_fSt):
{
  Eterm tmp_packed2 = I[1];
  if (!is_function2(Sb(tmp_packed2&BEAM_LOOSE_MASK), tb((tmp_packed2>>BEAM_LOOSE_SHIFT)))) {
    ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
    I += fb(BeamExtraData(I[0])) + 0;;
    Goto(*I);;
  }
  I += 2;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(i_apply):
{
  BeamInstr *next;
  HEAVY_SWAPOUT;
  next = apply(c_p, reg, NULL, 0);
  HEAVY_SWAPIN;;
  if (ERTS_LIKELY(next != NULL)) {
    SET_CP(c_p, I+1);
    SET_I((BeamInstr *) next);
    DTRACE_LOCAL_CALL(c_p, erts_code_to_codemfa(I));
    Dispatch();;
  }
  I = handle_error(c_p, I, reg, &bif_export[BIF_apply_3]->info.mfa);
  goto post_error_handling;;
}

OpCase(i_apply_fun):
{
  BeamInstr *next;
  HEAVY_SWAPOUT;
  next = apply_fun(c_p, r(0), x(1), reg);
  HEAVY_SWAPIN;;
  if (ERTS_LIKELY(next != NULL)) {
    SET_CP(c_p, I+1);
    SET_I(next);
    Dispatchfun();;
  }
  goto find_func_info;;
}

OpCase(i_apply_fun_last_Q):
{
  BeamInstr *next;
  HEAVY_SWAPOUT;
  next = apply_fun(c_p, r(0), x(1), reg);
  HEAVY_SWAPIN;;
  if (ERTS_LIKELY(next != NULL)) {
    SET_CP(c_p, (BeamInstr *) cp_val(*E));
    E = ADD_BYTE_OFFSET(E, Qb(BeamExtraData(I[0])));;
    SET_I(next);
    Dispatchfun();;
  }
  goto find_func_info;;
}

OpCase(i_apply_fun_only):
{
  BeamInstr *next;
  HEAVY_SWAPOUT;
  next = apply_fun(c_p, r(0), x(1), reg);
  HEAVY_SWAPIN;;
  if (ERTS_LIKELY(next != NULL)) {
    SET_I(next);
    Dispatchfun();;
  }
  goto find_func_info;;
}

OpCase(i_apply_last_Q):
{
  BeamInstr *next;
  HEAVY_SWAPOUT;
  next = apply(c_p, reg, I, Qb(BeamExtraData(I[0])));
  HEAVY_SWAPIN;;
  if (ERTS_LIKELY(next != NULL)) {
    SET_CP(c_p, (BeamInstr *) cp_val(*E));
    E = ADD_BYTE_OFFSET(E, Qb(BeamExtraData(I[0])));;
    SET_I((BeamInstr *) next);
    DTRACE_LOCAL_CALL(c_p, erts_code_to_codemfa(I));
    Dispatch();;
  }
  I = handle_error(c_p, I, reg, &bif_export[BIF_apply_3]->info.mfa);
  goto post_error_handling;;
}

OpCase(i_apply_only):
{
  BeamInstr *next;
  HEAVY_SWAPOUT;
  next = apply(c_p, reg, I, 0);
  HEAVY_SWAPIN;;
  if (ERTS_LIKELY(next != NULL)) {
    SET_I((BeamInstr *) next);
    DTRACE_LOCAL_CALL(c_p, erts_code_to_codemfa(I));
    Dispatch();;
  }
  I = handle_error(c_p, I, reg, &bif_export[BIF_apply_3]->info.mfa);
  goto post_error_handling;;
}

{
  Eterm BandOp1, BandOp2;
  OpCase(i_band_ssjd):
  {
    Eterm targ1;
    Eterm targ2;
    GetSource(I[1], targ1);
    GetSource(I[2], targ2);
    {
      BandOp1 = targ1;
      BandOp2 = targ2;
    }
  }
  I += 1;
  goto band__execute;

  OpCase(i_band_xcjd):
  {
    BandOp1 = xb(BeamExtraData(I[0]));
    BandOp2 = I[1];
  }
  goto band__execute;

  band__execute:
  {
    Eterm tmp_packed1 = I[2];
    Eterm dst = db((tmp_packed1>>BEAM_WIDE_SHIFT));
    Eterm* dst_ptr = REG_TARGET_PTR(dst);
    if (ERTS_LIKELY(is_both_small(BandOp1, BandOp2))) {
      /*
      * No need to untag -- TAG & TAG == TAG.
      */
      *dst_ptr = BandOp1 & BandOp2;
      SET_I((BeamInstr *) I+3);
      Goto(*I);;
    }
    do {
      Eterm result;
#ifdef DEBUG
      Eterm* orig_htop = HTOP;
      Eterm* orig_stop = E;
#endif
      DEBUG_SWAPOUT;
      result = erts_band (c_p, BandOp1, BandOp2);
      DEBUG_SWAPIN;
      ASSERT(orig_htop == HTOP && orig_stop == E);
      ERTS_HOLE_CHECK(c_p);
      if (ERTS_LIKELY(is_value(result))) {
        *dst_ptr = result;
        SET_I((BeamInstr *) I+3);
        Goto(*I);;
      }
      if (ERTS_LIKELY(jb(tmp_packed1&BEAM_WIDE_MASK))) {
        ASSERT(VALID_INSTR(*(I + (jb(tmp_packed1&BEAM_WIDE_MASK)) + 0)));
        I += jb(tmp_packed1&BEAM_WIDE_MASK) + 0;;
        Goto(*I);;
      }
      reg[0] = BandOp1;
      reg[1] = BandOp2;
      SWAPOUT;
      I = handle_error(c_p, I, reg, &bif_export[BIF_band_2]->info.mfa);
      goto post_error_handling;;
    } while (0);
  }

}

{
  ErtsBifFunc bf;
  Eterm tmp_reg[3];
  OpCase(i_bif3_body_sssbd):
  {
    Eterm targ1;
    GetSource(I[1], targ1);
    {
      tmp_reg[2] = targ1;
    }
  }
  I += 1;
  goto i_bif_body__fetch1;

  OpCase(i_bif2_body_ssbd):
  i_bif_body__fetch1:
  {
    Eterm targ1;
    GetSource(I[1], targ1);
    {
      tmp_reg[1] = targ1;
    }
  }
  I += 1;
  goto i_bif_body__fetch0;

  OpCase(i_bif1_body_sbd):
  i_bif_body__fetch0:
  {
    Eterm targ1;
    GetSource(I[1], targ1);
    {
      tmp_reg[0] = targ1;
    }
  }
  goto i_bif_body__call;

  i_bif_body__call:
  {
    Eterm dst = I[3];
    Eterm* dst_ptr = REG_TARGET_PTR(dst);
    bf = (BifFunction) I[2];
    do {
      Eterm result;
#ifdef DEBUG
      Eterm* orig_htop = HTOP;
      Eterm* orig_stop = E;
#endif

      ERTS_DBG_CHK_REDS(c_p, FCALLS);
      c_p->fcalls = FCALLS;
      PROCESS_MAIN_CHK_LOCKS(c_p);
      ASSERT(!ERTS_PROC_IS_EXITING(c_p));
      ERTS_CHK_MBUF_SZ(c_p);
      DEBUG_SWAPOUT;
      result = (*bf)(c_p, tmp_reg, I);
      DEBUG_SWAPIN;
      ASSERT(orig_htop == HTOP && orig_stop == E);
      ERTS_CHK_MBUF_SZ(c_p);
      ASSERT(!ERTS_PROC_IS_EXITING(c_p) || is_non_value(result));
      ERTS_VERIFY_UNUSED_TEMP_ALLOC(c_p);
      PROCESS_MAIN_CHK_LOCKS(c_p);
      ERTS_HOLE_CHECK(c_p);
      FCALLS = c_p->fcalls;
      ERTS_DBG_CHK_REDS(c_p, FCALLS);
      if (ERTS_LIKELY(is_value(result))) {
        *dst_ptr = result;
        SET_I((BeamInstr *) I+4);
        Goto(*I);;
      }
    } while (0);

    reg[0] = tmp_reg[0];
    reg[1] = tmp_reg[1];
    reg[2] = tmp_reg[2];
    SWAPOUT;
    I = handle_error(c_p, I, reg, ubif2mfa((void *) bf));
    goto post_error_handling;
  }

}

{
  ErtsBifFunc bf;
  Eterm tmp_reg[3];
  OpCase(i_bif3_sssfbd):
  {
    Eterm targ1;
    GetSource(I[1], targ1);
    {
      tmp_reg[2] = targ1;
    }
  }
  I += 1;
  goto i_bif__fetch1;

  OpCase(i_bif2_ssfbd):
  i_bif__fetch1:
  {
    Eterm targ1;
    GetSource(I[1], targ1);
    {
      tmp_reg[1] = targ1;
    }
  }
  I += 1;
  goto i_bif__fetch0;

  OpCase(i_bif1_sfbd):
  i_bif__fetch0:
  {
    Eterm targ1;
    GetSource(I[1], targ1);
    {
      tmp_reg[0] = targ1;
    }
  }
  goto i_bif__call;

  i_bif__call:
  {
    Eterm tmp_packed1 = I[2];
    Eterm dst = db((tmp_packed1>>BEAM_WIDE_SHIFT));
    Eterm* dst_ptr = REG_TARGET_PTR(dst);
    bf = (BifFunction) I[3];
    do {
      Eterm result;
#ifdef DEBUG
      Eterm* orig_htop = HTOP;
      Eterm* orig_stop = E;
#endif

      ERTS_DBG_CHK_REDS(c_p, FCALLS);
      c_p->fcalls = FCALLS;
      PROCESS_MAIN_CHK_LOCKS(c_p);
      ASSERT(!ERTS_PROC_IS_EXITING(c_p));
      ERTS_CHK_MBUF_SZ(c_p);
      DEBUG_SWAPOUT;
      result = (*bf)(c_p, tmp_reg, I);
      DEBUG_SWAPIN;
      ASSERT(orig_htop == HTOP && orig_stop == E);
      ERTS_CHK_MBUF_SZ(c_p);
      ASSERT(!ERTS_PROC_IS_EXITING(c_p) || is_non_value(result));
      ERTS_VERIFY_UNUSED_TEMP_ALLOC(c_p);
      PROCESS_MAIN_CHK_LOCKS(c_p);
      ERTS_HOLE_CHECK(c_p);
      FCALLS = c_p->fcalls;
      ERTS_DBG_CHK_REDS(c_p, FCALLS);
      if (ERTS_LIKELY(is_value(result))) {
        *dst_ptr = result;
        SET_I((BeamInstr *) I+4);
        Goto(*I);;
      }
    } while (0);

    ASSERT(VALID_INSTR(*(I + (fb(tmp_packed1&BEAM_WIDE_MASK)) + 0)));
    I += fb(tmp_packed1&BEAM_WIDE_MASK) + 0;;
    Goto(*I);;
  }

}

OpCase(i_bor_jssd):
{
  Eterm targ1;
  Eterm targ2;
  Eterm dst = I[3];
  Eterm* dst_ptr = REG_TARGET_PTR(dst);
  GetSource(I[1], targ1);
  GetSource(I[2], targ2);
  {
    if (ERTS_LIKELY(is_both_small(targ1, targ2))) {
      /*
      * No need to untag -- TAG | TAG == TAG.
      */
      *dst_ptr = targ1 | targ2;
      SET_I((BeamInstr *) I+4);
      Goto(*I);;
    }
    do {
      Eterm result;
#ifdef DEBUG
      Eterm* orig_htop = HTOP;
      Eterm* orig_stop = E;
#endif
      DEBUG_SWAPOUT;
      result = erts_bor (c_p, targ1, targ2);
      DEBUG_SWAPIN;
      ASSERT(orig_htop == HTOP && orig_stop == E);
      ERTS_HOLE_CHECK(c_p);
      if (ERTS_LIKELY(is_value(result))) {
        *dst_ptr = result;
        SET_I((BeamInstr *) I+4);
        Goto(*I);;
      }
      if (ERTS_LIKELY(jb(BeamExtraData(I[0])))) {
        ASSERT(VALID_INSTR(*(I + (jb(BeamExtraData(I[0]))) + 0)));
        I += jb(BeamExtraData(I[0])) + 0;;
        Goto(*I);;
      }
      reg[0] = targ1;
      reg[1] = targ2;
      SWAPOUT;
      I = handle_error(c_p, I, reg, &bif_export[BIF_bor_2]->info.mfa);
      goto post_error_handling;;
    } while (0);
  }
}

{
  Eterm Op1, Op2;
  Sint shift_left_count;
  OpCase(i_bsl_ssjd):
  {
    Eterm targ1;
    Eterm targ2;
    GetSource(I[1], targ1);
    GetSource(I[2], targ2);
    {
      Op1 = targ1;
      Op2 = targ2;
      shift_left_count = 0;
      if (ERTS_LIKELY(is_small(Op2))) {
        shift_left_count = signed_val(Op2);
      } else if (is_big(Op2)) {
        if (bignum_header_is_neg(*big_val(Op2))) {
          /*
          * N bsl NegativeBigNum is either 0 or -1, depending on
          * the sign of N. Since we don't believe this case
          * is common, do the calculation with the minimum
          * amount of code.
          */
          shift_left_count = MIN_SMALL;
        } else if (is_integer(Op1)) {
          /*
          * N bsl PositiveBigNum is too large to represent.
          */
          shift_left_count = MAX_SMALL;
        }
      }
    }
  }
  goto shift__execute;

  OpCase(i_bsr_ssjd):
  {
    Eterm targ1;
    Eterm targ2;
    GetSource(I[1], targ1);
    GetSource(I[2], targ2);
    {
      Op1 = targ1;
      Op2 = targ2;
      shift_left_count = 0;
      if (ERTS_LIKELY(is_small(Op2))) {
        shift_left_count = -signed_val(Op2);
      } else if (is_big(Op2)) {
        /*
        * N bsr NegativeBigNum == N bsl MAX_SMALL
        * N bsr PositiveBigNum == N bsl MIN_SMALL
        */
        shift_left_count = make_small(bignum_header_is_neg(*big_val(Op2)) ?
        MAX_SMALL : MIN_SMALL);
      }
    }
  }
  goto shift__execute;

  shift__execute:
  {
    Eterm tmp_packed1 = I[3];
    Eterm dst = db((tmp_packed1>>BEAM_WIDE_SHIFT));
    Eterm* dst_ptr = REG_TARGET_PTR(dst);
    Uint big_words_needed;

    if (ERTS_LIKELY(is_small(Op1))) {
      Sint int_res = signed_val(Op1);
      if (ERTS_UNLIKELY(shift_left_count == 0 || int_res == 0)) {
        if (ERTS_UNLIKELY(is_not_integer(Op2))) {
          goto shift_error;
        }
        if (int_res == 0) {
          *dst_ptr = Op1;
          SET_I((BeamInstr *) I+4);
          Goto(*I);;
        }
      } else if (shift_left_count < 0)  { /* Right shift */
        Eterm bsr_res;
        shift_left_count = -shift_left_count;
        if (shift_left_count >= SMALL_BITS-1) {
          bsr_res = (int_res < 0) ? SMALL_MINUS_ONE : SMALL_ZERO;
        } else {
          bsr_res = make_small(int_res >> shift_left_count);
        }
        *dst_ptr = bsr_res;
        SET_I((BeamInstr *) I+4);
        Goto(*I);;
      } else if (shift_left_count < SMALL_BITS-1) { /* Left shift */
        if ((int_res > 0 &&
        ((~(Uint)0 << ((SMALL_BITS-1)-shift_left_count)) & int_res) == 0) ||
        ((~(Uint)0 << ((SMALL_BITS-1)-shift_left_count)) & ~int_res) == 0) {
          *dst_ptr = make_small(int_res << shift_left_count);
          SET_I((BeamInstr *) I+4);
          Goto(*I);;
        }
      }
      big_words_needed = 1;   /* big_size(small_to_big(Op1)) */
      goto big_shift;
    } else if (is_big(Op1)) {
      if (shift_left_count == 0) {
        if (is_not_integer(Op2)) {
          goto shift_error;
        }
        *dst_ptr = Op1;
        SET_I((BeamInstr *) I+4);
        Goto(*I);;
      }
      big_words_needed = big_size(Op1);

      big_shift:
      if (shift_left_count > 0) {	/* Left shift. */
        big_words_needed += (shift_left_count / D_EXP);
      } else {	/* Right shift. */
        if (big_words_needed <= (-shift_left_count / D_EXP)) {
          big_words_needed = 3;       /* ??? */
        } else {
          big_words_needed -= (-shift_left_count / D_EXP);
        }
      }
      {
        Eterm tmp_big[2];
        Sint big_need_size = 1 + BIG_NEED_SIZE(big_words_needed+1);
        Eterm* hp;
        Eterm* hp_end;

        /*
        * Slightly conservative check the size to avoid
        * allocating huge amounts of memory for bignums that
        * clearly would overflow the arity in the header
        * word.
        */
        if (big_need_size-8 > BIG_ARITY_MAX) {
          c_p->freason = SYSTEM_LIMIT;

          /*
          * In a correctly working program, we expect failures in
          * guards to be more likely than failures in bodies.
          */

          if (ERTS_LIKELY(jb(tmp_packed1&BEAM_WIDE_MASK))) {
            ASSERT(VALID_INSTR(*(I + (jb(tmp_packed1&BEAM_WIDE_MASK)) + 0)));
            I += jb(tmp_packed1&BEAM_WIDE_MASK) + 0;;
            Goto(*I);;
          }
          goto find_func_info;;;
        }
        hp = HeapFragOnlyAlloc(c_p, big_need_size);
        if (is_small(Op1)) {
          Op1 = small_to_big(signed_val(Op1), tmp_big);
        }
        Op1 = big_lshift(Op1, shift_left_count, hp);
        hp_end = hp + big_need_size;
        if (is_big(Op1)) {
          hp += bignum_header_arity(*hp) + 1;
        }
        HRelease(c_p, hp_end, hp);
        if (ERTS_UNLIKELY(is_nil(Op1))) {
          /*
          * This result must have been only slighty larger
          * than allowed since it wasn't caught by the
          * previous test.
          */
          c_p->freason = SYSTEM_LIMIT;

          /*
          * In a correctly working program, we expect failures in
          * guards to be more likely than failures in bodies.
          */

          if (ERTS_LIKELY(jb(tmp_packed1&BEAM_WIDE_MASK))) {
            ASSERT(VALID_INSTR(*(I + (jb(tmp_packed1&BEAM_WIDE_MASK)) + 0)));
            I += jb(tmp_packed1&BEAM_WIDE_MASK) + 0;;
            Goto(*I);;
          }
          goto find_func_info;;;
        }
        ERTS_HOLE_CHECK(c_p);
        *dst_ptr = Op1;
        SET_I((BeamInstr *) I+4);
        Goto(*I);;
      }
    }

    /*
    * One or more non-integer arguments.
    */
    shift_error:
    c_p->freason = BADARITH;
    if (jb(tmp_packed1&BEAM_WIDE_MASK)) {
      ASSERT(VALID_INSTR(*(I + (jb(tmp_packed1&BEAM_WIDE_MASK)) + 0)));
      I += jb(tmp_packed1&BEAM_WIDE_MASK) + 0;;
      Goto(*I);;
    } else {
      reg[0] = Op1;
      reg[1] = Op2;
      SWAPOUT;
      if (IsOpCode(I[0], i_bsl_ssjd)) {
        I = handle_error(c_p, I, reg, &bif_export[BIF_bsl_2]->info.mfa);
      } else {
        ASSERT(IsOpCode(I[0], i_bsr_ssjd));
        I = handle_error(c_p, I, reg, &bif_export[BIF_bsr_2]->info.mfa);
      }
      goto post_error_handling;
    }
  }

}

OpCase(i_bxor_jssd):
{
  Eterm targ1;
  Eterm targ2;
  Eterm dst = I[3];
  Eterm* dst_ptr = REG_TARGET_PTR(dst);
  GetSource(I[1], targ1);
  GetSource(I[2], targ2);
  {
    if (ERTS_LIKELY(is_both_small(targ1, targ2))) {
      /*
      * TAG ^ TAG == 0.
      *
      * Therefore, we perform the XOR operation on the tagged values,
      * and OR in the tag bits.
      */
      *dst_ptr = (targ1 ^ targ2) | make_small(0);
      SET_I((BeamInstr *) I+4);
      Goto(*I);;
    }
    do {
      Eterm result;
#ifdef DEBUG
      Eterm* orig_htop = HTOP;
      Eterm* orig_stop = E;
#endif
      DEBUG_SWAPOUT;
      result = erts_bxor (c_p, targ1, targ2);
      DEBUG_SWAPIN;
      ASSERT(orig_htop == HTOP && orig_stop == E);
      ERTS_HOLE_CHECK(c_p);
      if (ERTS_LIKELY(is_value(result))) {
        *dst_ptr = result;
        SET_I((BeamInstr *) I+4);
        Goto(*I);;
      }
      if (ERTS_LIKELY(jb(BeamExtraData(I[0])))) {
        ASSERT(VALID_INSTR(*(I + (jb(BeamExtraData(I[0]))) + 0)));
        I += jb(BeamExtraData(I[0])) + 0;;
        Goto(*I);;
      }
      reg[0] = targ1;
      reg[1] = targ2;
      SWAPOUT;
      I = handle_error(c_p, I, reg, &bif_export[BIF_bxor_2]->info.mfa);
      goto post_error_handling;;
    } while (0);
  }
}

OpCase(i_call_ext_e):
{
  SET_CP(c_p, I+2);
  DTRACE_GLOBAL_CALL_FROM_EXPORT(c_p, I[1]);
  // Dispatchx assumes the Export* is in Arg(0)
  I = (&I[1]) - 1;
  Dispatchx();;
}

OpCase(i_call_ext_last_eQ):
{
  SET_CP(c_p, (BeamInstr *) cp_val(*E));
  E = ADD_BYTE_OFFSET(E, Qb(BeamExtraData(I[0])));;
  DTRACE_GLOBAL_CALL_FROM_EXPORT(c_p, I[1]);
  // Dispatchx assumes the Export* is in Arg(0)
  I = (&I[1]) - 1;
  Dispatchx();;
}

OpCase(i_call_ext_only_e):
{
  DTRACE_GLOBAL_CALL_FROM_EXPORT(c_p, I[1]);
  // Dispatchx assumes the Export* is in Arg(0)
  I = (&I[1]) - 1;
  Dispatchx();;
}

OpCase(i_call_f):
{
  SET_CP(c_p, I+1);
  ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
  I += fb(BeamExtraData(I[0])) + 0;;
  DTRACE_LOCAL_CALL(c_p, erts_code_to_codemfa(I));
  Dispatch();;
}

OpCase(i_call_fun_last_tQ):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  BeamInstr *next;
  HEAVY_SWAPOUT;
  next = call_fun(c_p, tb(tmp_packed1&BEAM_TIGHT_MASK), reg, THE_NON_VALUE);
  HEAVY_SWAPIN;;
  if (ERTS_LIKELY(next != NULL)) {
    SET_CP(c_p, (BeamInstr *) cp_val(*E));
    E = ADD_BYTE_OFFSET(E, Qb((tmp_packed1>>BEAM_TIGHT_SHIFT)));;
    SET_I(next);
    Dispatchfun();;
  }
  goto find_func_info;;
}

OpCase(i_call_fun_t):
{
  BeamInstr *next;
  HEAVY_SWAPOUT;
  next = call_fun(c_p, tb(BeamExtraData(I[0])), reg, THE_NON_VALUE);
  HEAVY_SWAPIN;;
  if (ERTS_LIKELY(next != NULL)) {
    SET_CP(c_p, I+1);
    SET_I(next);
    Dispatchfun();;
  }
  goto find_func_info;;
}

OpCase(i_call_last_fQ):
{
  SET_CP(c_p, (BeamInstr *) cp_val(*E));
  E = ADD_BYTE_OFFSET(E, I[1]);;
  ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
  I += fb(BeamExtraData(I[0])) + 0;;
  DTRACE_LOCAL_CALL(c_p, erts_code_to_codemfa(I));
  Dispatch();;
}

OpCase(i_call_only_f):
{
  ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
  I += fb(BeamExtraData(I[0])) + 0;;
  DTRACE_LOCAL_CALL(c_p, erts_code_to_codemfa(I));
  Dispatch();;
}

{
  Eterm element_tuple;
  OpCase(i_element_xjsd):
  {
    element_tuple = xb(BeamExtraData(I[0]));
  }
  goto element_group__execute;

  OpCase(i_element_yjsd):
  {
    element_tuple = yb(BeamExtraData(I[0]));
  }
  goto element_group__execute;

  element_group__execute:
  {
    Eterm tmp_packed1 = I[1];
    Eterm targ1;
    Eterm dst = db((tmp_packed1>>BEAM_WIDE_SHIFT));
    Eterm* dst_ptr = REG_TARGET_PTR(dst);
    GetSource(I[2], targ1);
    {
      Eterm element_index = targ1;
      if (ERTS_LIKELY(is_small(element_index) && is_tuple(element_tuple))) {
        Eterm* tp = tuple_val(element_tuple);

        if ((signed_val(element_index) >= 1) &&
        (signed_val(element_index) <= arityval(*tp))) {
          *dst_ptr = tp[signed_val(element_index)];
          SET_I((BeamInstr *) I+3);
          Goto(*I);;
        }
      }
      c_p->freason = BADARG;
      if (ERTS_LIKELY(jb(tmp_packed1&BEAM_WIDE_MASK))) {
        ASSERT(VALID_INSTR(*(I + (jb(tmp_packed1&BEAM_WIDE_MASK)) + 0)));
        I += jb(tmp_packed1&BEAM_WIDE_MASK) + 0;;
        Goto(*I);;
      }
      reg[0] = element_index;
      reg[1] = element_tuple;
      SWAPOUT;
      I = handle_error(c_p, I, reg, &bif_export[BIF_element_2]->info.mfa);
      goto post_error_handling;;
    }
  }

}

{
  Eterm fast_element_tuple;
  OpCase(i_fast_element_xjId):
  {
    fast_element_tuple = xb(BeamExtraData(I[0]));
  }
  goto fast_element_group__execute;

  OpCase(i_fast_element_yjId):
  {
    fast_element_tuple = yb(BeamExtraData(I[0]));
  }
  goto fast_element_group__execute;

  fast_element_group__execute:
  {
    Eterm tmp_packed1 = I[2];
    Eterm dst = db((tmp_packed1>>BEAM_WIDE_SHIFT));
    Eterm* dst_ptr = REG_TARGET_PTR(dst);
    if (ERTS_LIKELY(is_tuple(fast_element_tuple))) {
      Eterm* tp = tuple_val(fast_element_tuple);
      Eterm pos = Ib(tmp_packed1&BEAM_WIDE_MASK);	/* Untagged integer >= 1 */
      if (pos <= arityval(*tp)) {
        *dst_ptr = tp[pos];
        SET_I((BeamInstr *) I+3);
        Goto(*I);;
      }
    }
    c_p->freason = BADARG;
    if (ERTS_LIKELY(I[1])) {
      ASSERT(VALID_INSTR(*(I + (I[1]) + 0)));
      I += I[1] + 0;;
      Goto(*I);;
    }
    reg[0] = make_small(Ib(tmp_packed1&BEAM_WIDE_MASK));
    reg[1] = fast_element_tuple;
    SWAPOUT;
    I = handle_error(c_p, I, reg, &bif_export[BIF_element_2]->info.mfa);
    goto post_error_handling;;
  }

}

OpCase(i_get_hash_cId):
{
  Eterm tmp_packed1 = I[2];
  Eterm dst = db((tmp_packed1>>BEAM_WIDE_SHIFT));
  Eterm* dst_ptr = REG_TARGET_PTR(dst);
  BeamInstr next_pf = BeamCodeAddr(I[3]);
  *dst_ptr = erts_pd_hash_get_with_hx(c_p, Ib(tmp_packed1&BEAM_WIDE_MASK), I[1]);
  I += 3;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(i_get_map_element_fxxx):
{
  Eterm tmp_packed2 = I[1];
  Eterm res = get_map_element(xb(tmp_packed2&BEAM_TIGHT_MASK), xb((tmp_packed2>>BEAM_TIGHT_SHIFT)&BEAM_TIGHT_MASK));
  if (is_non_value(res)) {
    ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
    I += fb(BeamExtraData(I[0])) + 0;;
    Goto(*I);;
  }
  xb((tmp_packed2>>(2*BEAM_TIGHT_SHIFT))) = res;
  I += 2;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(i_get_map_element_fxxy):
{
  Eterm tmp_packed2 = I[1];
  Eterm res = get_map_element(xb(tmp_packed2&BEAM_TIGHT_MASK), xb((tmp_packed2>>BEAM_TIGHT_SHIFT)&BEAM_TIGHT_MASK));
  if (is_non_value(res)) {
    ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
    I += fb(BeamExtraData(I[0])) + 0;;
    Goto(*I);;
  }
  yb((tmp_packed2>>(2*BEAM_TIGHT_SHIFT))) = res;
  I += 2;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(i_get_map_element_fxyx):
{
  Eterm tmp_packed2 = I[1];
  Eterm res = get_map_element(xb(tmp_packed2&BEAM_TIGHT_MASK), yb((tmp_packed2>>BEAM_TIGHT_SHIFT)&BEAM_TIGHT_MASK));
  if (is_non_value(res)) {
    ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
    I += fb(BeamExtraData(I[0])) + 0;;
    Goto(*I);;
  }
  xb((tmp_packed2>>(2*BEAM_TIGHT_SHIFT))) = res;
  I += 2;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(i_get_map_element_fxyy):
{
  Eterm tmp_packed2 = I[1];
  Eterm res = get_map_element(xb(tmp_packed2&BEAM_TIGHT_MASK), yb((tmp_packed2>>BEAM_TIGHT_SHIFT)&BEAM_TIGHT_MASK));
  if (is_non_value(res)) {
    ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
    I += fb(BeamExtraData(I[0])) + 0;;
    Goto(*I);;
  }
  yb((tmp_packed2>>(2*BEAM_TIGHT_SHIFT))) = res;
  I += 2;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(i_get_map_element_fyxx):
{
  Eterm tmp_packed2 = I[1];
  Eterm res = get_map_element(yb(tmp_packed2&BEAM_TIGHT_MASK), xb((tmp_packed2>>BEAM_TIGHT_SHIFT)&BEAM_TIGHT_MASK));
  if (is_non_value(res)) {
    ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
    I += fb(BeamExtraData(I[0])) + 0;;
    Goto(*I);;
  }
  xb((tmp_packed2>>(2*BEAM_TIGHT_SHIFT))) = res;
  I += 2;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(i_get_map_element_fyxy):
{
  Eterm tmp_packed2 = I[1];
  Eterm res = get_map_element(yb(tmp_packed2&BEAM_TIGHT_MASK), xb((tmp_packed2>>BEAM_TIGHT_SHIFT)&BEAM_TIGHT_MASK));
  if (is_non_value(res)) {
    ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
    I += fb(BeamExtraData(I[0])) + 0;;
    Goto(*I);;
  }
  yb((tmp_packed2>>(2*BEAM_TIGHT_SHIFT))) = res;
  I += 2;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(i_get_map_element_fyyx):
{
  Eterm tmp_packed2 = I[1];
  Eterm res = get_map_element(yb(tmp_packed2&BEAM_TIGHT_MASK), yb((tmp_packed2>>BEAM_TIGHT_SHIFT)&BEAM_TIGHT_MASK));
  if (is_non_value(res)) {
    ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
    I += fb(BeamExtraData(I[0])) + 0;;
    Goto(*I);;
  }
  xb((tmp_packed2>>(2*BEAM_TIGHT_SHIFT))) = res;
  I += 2;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(i_get_map_element_fyyy):
{
  Eterm tmp_packed2 = I[1];
  Eterm res = get_map_element(yb(tmp_packed2&BEAM_TIGHT_MASK), yb((tmp_packed2>>BEAM_TIGHT_SHIFT)&BEAM_TIGHT_MASK));
  if (is_non_value(res)) {
    ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
    I += fb(BeamExtraData(I[0])) + 0;;
    Goto(*I);;
  }
  yb((tmp_packed2>>(2*BEAM_TIGHT_SHIFT))) = res;
  I += 2;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(i_get_map_element_hash_fxcIx):
{
  Eterm tmp_packed2 = I[1];
  Eterm res = get_map_element_hash(xb(tmp_packed2&BEAM_WIDE_MASK), I[2], Ib((tmp_packed2>>BEAM_WIDE_SHIFT)));
  if (is_non_value(res)) {
    ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
    I += fb(BeamExtraData(I[0])) + 0;;
    Goto(*I);;
  }
  xb(I[3]) = res;
  I += 4;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(i_get_map_element_hash_fxcIy):
{
  Eterm tmp_packed2 = I[1];
  Eterm res = get_map_element_hash(xb(tmp_packed2&BEAM_WIDE_MASK), I[2], Ib((tmp_packed2>>BEAM_WIDE_SHIFT)));
  if (is_non_value(res)) {
    ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
    I += fb(BeamExtraData(I[0])) + 0;;
    Goto(*I);;
  }
  yb(I[3]) = res;
  I += 4;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(i_get_map_element_hash_fycIx):
{
  Eterm tmp_packed2 = I[1];
  Eterm res = get_map_element_hash(yb(tmp_packed2&BEAM_WIDE_MASK), I[2], Ib((tmp_packed2>>BEAM_WIDE_SHIFT)));
  if (is_non_value(res)) {
    ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
    I += fb(BeamExtraData(I[0])) + 0;;
    Goto(*I);;
  }
  xb(I[3]) = res;
  I += 4;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(i_get_map_element_hash_fycIy):
{
  Eterm tmp_packed2 = I[1];
  Eterm res = get_map_element_hash(yb(tmp_packed2&BEAM_WIDE_MASK), I[2], Ib((tmp_packed2>>BEAM_WIDE_SHIFT)));
  if (is_non_value(res)) {
    ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
    I += fb(BeamExtraData(I[0])) + 0;;
    Goto(*I);;
  }
  yb(I[3]) = res;
  I += 4;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(i_get_map_elements_fsI):
{
  Eterm targ1;
  GetSource(I[1], targ1);
  {
    Eterm map;
    BeamInstr *fs;
    Uint sz, n;

    map = targ1;

    /* This instruction assumes Arg1 is a map,
    * i.e. that it follows a test is_map if needed.
    */

    n  = (Uint)I[2] / 3;
    fs = I+3;

    if (is_flatmap(map)) {
      flatmap_t *mp;
      Eterm *ks;
      Eterm *vs;

      mp = (flatmap_t *)flatmap_val(map);
      sz = flatmap_get_size(mp);

      if (sz == 0) {
        ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
        I += fb(BeamExtraData(I[0])) + 0;;
        Goto(*I);;
      }

      ks = flatmap_get_keys(mp);
      vs = flatmap_get_values(mp);

      while(sz) {
        if (EQ((Eterm) fs[0], *ks)) {
          PUT_TERM_REG(*vs, fs[1]);
          n--;
          fs += 3;
          /* no more values to fetch, we are done */
          if (n == 0) {
            SET_I((BeamInstr *) fs);
            Goto(*I);;
          }
        }
        ks++, sz--, vs++;
      }
      ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
      I += fb(BeamExtraData(I[0])) + 0;;
      Goto(*I);;
    } else {
      const Eterm *v;
      Uint32 hx;
      ASSERT(is_hashmap(map));
      while(n--) {
        hx = fs[2];
        ASSERT(hx == hashmap_make_hash((Eterm)fs[0]));
        if ((v = erts_hashmap_get(hx, (Eterm)fs[0], map)) == NULL) {
          ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
          I += fb(BeamExtraData(I[0])) + 0;;
          Goto(*I);;
        }
        PUT_TERM_REG(*v, fs[1]);
        fs += 3;
      }
      SET_I((BeamInstr *) fs);
      Goto(*I);;
    }
  }
}

OpCase(i_get_sd):
{
  Eterm targ1;
  Eterm dst = db(BeamExtraData(I[0]));
  Eterm* dst_ptr = REG_TARGET_PTR(dst);
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  GetSource(I[1], targ1);
  {
    *dst_ptr = erts_pd_hash_get(c_p, targ1);
    I += 2;
    ASSERT(VALID_INSTR(next_pf));
    GotoPF(next_pf);
  }
}

OpCase(i_get_tuple_element2_dst_xPxx):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  Eterm* src;
  Eterm E1, E2;
  src = ADD_BYTE_OFFSET(tuple_val(x(tmp_packed1&BEAM_TIGHTEST_MASK)), I[1]);
  E1 = src[0];
  E2 = src[1];
  x((tmp_packed1>>BEAM_TIGHTEST_SHIFT)&BEAM_TIGHTEST_MASK) = E1;
  x((tmp_packed1>>(2*BEAM_TIGHTEST_SHIFT))) = E2;
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(i_get_tuple_element2_dst_xPyy):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  Eterm* src;
  Eterm E1, E2;
  src = ADD_BYTE_OFFSET(tuple_val(x(tmp_packed1&BEAM_TIGHTEST_MASK)), I[1]);
  E1 = src[0];
  E2 = src[1];
  y((tmp_packed1>>BEAM_TIGHTEST_SHIFT)&BEAM_TIGHTEST_MASK) = E1;
  y((tmp_packed1>>(2*BEAM_TIGHTEST_SHIFT))) = E2;
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(i_get_tuple_element2_xPx):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  Eterm* src;
  Eterm* dst;
  Eterm E1, E2;
  src = ADD_BYTE_OFFSET(tuple_val(xb(tmp_packed1&BEAM_TIGHT_MASK)), I[1]);
  dst = &(xb((tmp_packed1>>BEAM_TIGHT_SHIFT)));
  E1 = src[0];
  E2 = src[1];
  dst[0] = E1;
  dst[1] = E2;
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(i_get_tuple_element3_xPx):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  Eterm* src;
  Eterm* dst;
  Eterm E1, E2, E3;
  src = ADD_BYTE_OFFSET(tuple_val(xb(tmp_packed1&BEAM_TIGHT_MASK)), I[1]);
  dst = &(xb((tmp_packed1>>BEAM_TIGHT_SHIFT)));
  E1 = src[0];
  E2 = src[1];
  E3 = src[2];
  dst[0] = E1;
  dst[1] = E2;
  dst[2] = E3;
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(i_get_tuple_element_xPx):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  Eterm* src = ADD_BYTE_OFFSET(tuple_val(xb(tmp_packed1&BEAM_TIGHT_MASK)), I[1]);
  xb((tmp_packed1>>BEAM_TIGHT_SHIFT)) = *src;
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(i_get_tuple_element_xPy):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  Eterm* src = ADD_BYTE_OFFSET(tuple_val(xb(tmp_packed1&BEAM_TIGHT_MASK)), I[1]);
  yb((tmp_packed1>>BEAM_TIGHT_SHIFT)) = *src;
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(i_get_tuple_element_yPx):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  Eterm* src = ADD_BYTE_OFFSET(tuple_val(yb(tmp_packed1&BEAM_TIGHT_MASK)), I[1]);
  xb((tmp_packed1>>BEAM_TIGHT_SHIFT)) = *src;
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(i_get_tuple_element_yPy):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  Eterm* src = ADD_BYTE_OFFSET(tuple_val(yb(tmp_packed1&BEAM_TIGHT_MASK)), I[1]);
  yb((tmp_packed1>>BEAM_TIGHT_SHIFT)) = *src;
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

{
  Eterm increment_reg_val;
  OpCase(i_increment_rWd):
  {
    increment_reg_val = r(0);
  }
  goto increment__execute;

  OpCase(i_increment_xWd):
  {
    increment_reg_val = xb(BeamExtraData(I[0]));
  }
  goto increment__execute;

  OpCase(i_increment_yWd):
  {
    increment_reg_val = yb(BeamExtraData(I[0]));
  }
  goto increment__execute;

  increment__execute:
  {
    Eterm dst = I[2];
    Eterm* dst_ptr = REG_TARGET_PTR(dst);
    Eterm increment_val = I[1];
    Eterm result;

    if (ERTS_LIKELY(is_small(increment_reg_val))) {
#ifdef HAVE_OVERFLOW_CHECK_BUILTINS
      Sint lhs_tagged, rhs_untagged, res;

      /* See plus.execute */
      lhs_tagged = increment_reg_val;
      rhs_untagged = (Sint)increment_val << _TAG_IMMED1_SIZE;

      if (ERTS_LIKELY(!__builtin_add_overflow(lhs_tagged, rhs_untagged, &res))) {
        ASSERT(is_small(res));
        *dst_ptr = res;
        SET_I((BeamInstr *) I+3);
        Goto(*I);;
      }
#else
      Sint i = signed_val(increment_reg_val) + increment_val;
      if (ERTS_LIKELY(IS_SSMALL(i))) {
        *dst_ptr = make_small(i);
        SET_I((BeamInstr *) I+3);
        Goto(*I);;
      }
#endif
    }

    result = erts_mixed_plus(c_p, increment_reg_val, make_small(increment_val));
    ERTS_HOLE_CHECK(c_p);
    if (ERTS_LIKELY(is_value(result))) {
      *dst_ptr = result;
      SET_I((BeamInstr *) I+3);
      Goto(*I);;
    }
    ASSERT(c_p->freason != BADMATCH || is_value(c_p->fvalue));
    goto find_func_info;
  }

}

OpCase(i_int_bnot_jSd):
{
  Eterm tmp_packed2 = I[1];
  Eterm dst = db((tmp_packed2>>BEAM_LOOSE_SHIFT));
  Eterm* dst_ptr = REG_TARGET_PTR(dst);
  Eterm bnot_val = Sb(tmp_packed2&BEAM_LOOSE_MASK);
  Eterm result;

  if (ERTS_LIKELY(is_small(bnot_val))) {
    result = make_small(~signed_val(bnot_val));
  } else {
    result = erts_bnot(c_p, bnot_val);
    ERTS_HOLE_CHECK(c_p);
    if (ERTS_UNLIKELY(is_nil(result))) {
      if (ERTS_LIKELY(jb(BeamExtraData(I[0])))) {
        ASSERT(VALID_INSTR(*(I + (jb(BeamExtraData(I[0]))) + 0)));
        I += jb(BeamExtraData(I[0])) + 0;;
        Goto(*I);;
      }
      reg[0] = bnot_val;
      SWAPOUT;
      I = handle_error(c_p, I, reg, &bif_export[BIF_bnot_1]->info.mfa);
      goto post_error_handling;;
    }
  }
  *dst_ptr = result;
  I += 2;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(i_int_div_jssd):
{
  Eterm targ1;
  Eterm targ2;
  Eterm dst = I[3];
  Eterm* dst_ptr = REG_TARGET_PTR(dst);
  GetSource(I[1], targ1);
  GetSource(I[2], targ2);
  {
    Eterm op1 = targ1;
    Eterm op2 = targ2;
    if (ERTS_UNLIKELY(op2 == SMALL_ZERO)) {
      c_p->freason = BADARITH;
      if (ERTS_LIKELY(jb(BeamExtraData(I[0])))) {
        ASSERT(VALID_INSTR(*(I + (jb(BeamExtraData(I[0]))) + 0)));
        I += jb(BeamExtraData(I[0])) + 0;;
        Goto(*I);;
      }
      reg[0] = op1;
      reg[1] = op2;
      SWAPOUT;
      I = handle_error(c_p, I, reg, &bif_export[BIF_intdiv_2]->info.mfa);
      goto post_error_handling;;
    } else if (ERTS_LIKELY(is_both_small(op1, op2))) {
      Sint ires = signed_val(op1) / signed_val(op2);
      if (ERTS_LIKELY(IS_SSMALL(ires))) {
        *dst_ptr = make_small(ires);
        SET_I((BeamInstr *) I+4);
        Goto(*I);;
      }
    }
    do {
      Eterm result;
#ifdef DEBUG
      Eterm* orig_htop = HTOP;
      Eterm* orig_stop = E;
#endif
      DEBUG_SWAPOUT;
      result = erts_int_div (c_p, op1, op2);
      DEBUG_SWAPIN;
      ASSERT(orig_htop == HTOP && orig_stop == E);
      ERTS_HOLE_CHECK(c_p);
      if (ERTS_LIKELY(is_value(result))) {
        *dst_ptr = result;
        SET_I((BeamInstr *) I+4);
        Goto(*I);;
      }
      if (ERTS_LIKELY(jb(BeamExtraData(I[0])))) {
        ASSERT(VALID_INSTR(*(I + (jb(BeamExtraData(I[0]))) + 0)));
        I += jb(BeamExtraData(I[0])) + 0;;
        Goto(*I);;
      }
      reg[0] = op1;
      reg[1] = op2;
      SWAPOUT;
      I = handle_error(c_p, I, reg, &bif_export[BIF_intdiv_2]->info.mfa);
      goto post_error_handling;;
    } while (0);
  }
}

OpCase(i_is_eq_exact_immed_frc):
{
  if (r(0) != I[1]) {
    ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
    I += fb(BeamExtraData(I[0])) + 0;;
    Goto(*I);;
  }
  I += 2;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(i_is_eq_exact_immed_fxc):
{
  if (xb(I[1]) != I[2]) {
    ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
    I += fb(BeamExtraData(I[0])) + 0;;
    Goto(*I);;
  }
  I += 3;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(i_is_eq_exact_immed_fyc):
{
  if (yb(I[1]) != I[2]) {
    ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
    I += fb(BeamExtraData(I[0])) + 0;;
    Goto(*I);;
  }
  I += 3;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(i_is_eq_exact_literal_fxc):
{
  Eterm src = xb(I[1]);
  if (is_immed(src) || !eq(src, I[2])) {
    ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
    I += fb(BeamExtraData(I[0])) + 0;;
    Goto(*I);;
  }
  I += 3;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(i_is_eq_exact_literal_fyc):
{
  Eterm src = yb(I[1]);
  if (is_immed(src) || !eq(src, I[2])) {
    ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
    I += fb(BeamExtraData(I[0])) + 0;;
    Goto(*I);;
  }
  I += 3;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(i_is_ne_exact_immed_fxc):
{
  if (xb(I[1]) == I[2]) {
    ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
    I += fb(BeamExtraData(I[0])) + 0;;
    Goto(*I);;
  }
  I += 3;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(i_is_ne_exact_immed_fyc):
{
  if (yb(I[1]) == I[2]) {
    ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
    I += fb(BeamExtraData(I[0])) + 0;;
    Goto(*I);;
  }
  I += 3;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(i_is_ne_exact_literal_fxc):
{
  Eterm src = xb(I[1]);
  if (!is_immed(src) && eq(src, I[2])) {
    ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
    I += fb(BeamExtraData(I[0])) + 0;;
    Goto(*I);;
  }
  I += 3;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(i_is_ne_exact_literal_fyc):
{
  Eterm src = yb(I[1]);
  if (!is_immed(src) && eq(src, I[2])) {
    ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
    I += fb(BeamExtraData(I[0])) + 0;;
    Goto(*I);;
  }
  I += 3;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

{
  Eterm index;
  OpCase(i_jump_on_val_xfIW):
  {
    index = xb(BeamExtraData(I[0]));
  }
  goto jump_on_val__execute;

  OpCase(i_jump_on_val_yfIW):
  {
    index = yb(BeamExtraData(I[0]));
  }
  goto jump_on_val__execute;

  jump_on_val__execute:
  {
    Eterm tmp_packed1 = I[1];
    if (is_small(index)) {
      index = (Uint) (signed_val(index) - I[2]);
      if (index < Ib((tmp_packed1>>BEAM_WIDE_SHIFT))) {
        Sint32* jump_tab = (Sint32 *) (I+3);
        ASSERT(VALID_INSTR(*(I + (jump_tab[index]) + 0)));
        I += jump_tab[index] + 0;;
        Goto(*I);;
      }
    }
    ASSERT(VALID_INSTR(*(I + (fb(tmp_packed1&BEAM_WIDE_MASK)) + 0)));
    I += fb(tmp_packed1&BEAM_WIDE_MASK) + 0;;
    Goto(*I);;;
  }

}

{
  Eterm index;
  OpCase(i_jump_on_val_zero_xfI):
  {
    index = xb(BeamExtraData(I[0]));
  }
  goto jump_on_val_zero__execute;

  OpCase(i_jump_on_val_zero_yfI):
  {
    index = yb(BeamExtraData(I[0]));
  }
  goto jump_on_val_zero__execute;

  jump_on_val_zero__execute:
  {
    Eterm tmp_packed1 = I[1];
    if (is_small(index)) {
      index = (Uint) (signed_val(index) - 0);
      if (index < Ib((tmp_packed1>>BEAM_WIDE_SHIFT))) {
        Sint32* jump_tab = (Sint32 *) (I+2);
        ASSERT(VALID_INSTR(*(I + (jump_tab[index]) + 0)));
        I += jump_tab[index] + 0;;
        Goto(*I);;
      }
    }
    ASSERT(VALID_INSTR(*(I + (fb(tmp_packed1&BEAM_WIDE_MASK)) + 0)));
    I += fb(tmp_packed1&BEAM_WIDE_MASK) + 0;;
    Goto(*I);;;
  }

}

{
  OpCase(i_length_jtd):
  {
    i_length_start__:
    ;
  }
  goto i_length__execute;

  i_length__execute:
  {
    Eterm tmp_packed1 = I[2];
    Eterm dst = db((tmp_packed1>>BEAM_LOOSE_SHIFT));
    Eterm* dst_ptr = REG_TARGET_PTR(dst);
    Eterm result;
    Uint live;

    ERTS_DBG_CHK_REDS(c_p, FCALLS);
    c_p->fcalls = FCALLS;
    PROCESS_MAIN_CHK_LOCKS(c_p);
    ASSERT(!ERTS_PROC_IS_EXITING(c_p));
    ERTS_CHK_MBUF_SZ(c_p);
    DEBUG_SWAPOUT;

    live = tb(tmp_packed1&BEAM_LOOSE_MASK);
    result = erts_trapping_length_1(c_p, reg+live);

    DEBUG_SWAPIN;
    ERTS_CHK_MBUF_SZ(c_p);
    ASSERT(!ERTS_PROC_IS_EXITING(c_p) || is_non_value(result));
    ERTS_VERIFY_UNUSED_TEMP_ALLOC(c_p);
    PROCESS_MAIN_CHK_LOCKS(c_p);
    ERTS_HOLE_CHECK(c_p);
    FCALLS = c_p->fcalls;
    ERTS_DBG_CHK_REDS(c_p, FCALLS);
    if (ERTS_LIKELY(is_value(result))) {
      /* Successful calculation of the list length. */
      dst_ptr = REG_TARGET_PTR(dst);
      *dst_ptr = result;
      SET_I((BeamInstr *) I+3);
      Goto(*I);;
    } else if (c_p->freason == TRAP) {
      /*
      * Good so far, but there is more work to do. Yield.
      */
      c_p->i = I;
      ASSERT(VALID_INSTR(*c_p->i));;
      SWAPOUT;
      c_p->arity = live + 3;
      c_p->current = NULL;
      goto context_switch3;
    } else {
      /* Error. */
      if (ERTS_LIKELY(I[1])) {
        ASSERT(VALID_INSTR(*(I + (I[1]) + 0)));
        I += I[1] + 0;;
        Goto(*I);;
      }
      reg[0] = reg[live+2];
      SWAPOUT;
      I = handle_error(c_p, I, reg, &bif_export[BIF_length_1]->info.mfa);
      goto post_error_handling;;
    }

  }

}

OpCase(i_length_setup_tx):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  Uint live = tb(tmp_packed1&BEAM_TIGHT_MASK);
  Eterm src = xb((tmp_packed1>>BEAM_TIGHT_SHIFT));

  reg[live] = src;
  reg[live+1] = make_small(0);
  reg[live+2] = src;

  /* This instruction is always followed by i_length */
  SET_I(I+1);
  goto i_length_start__;

}

OpCase(i_length_setup_ty):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  Uint live = tb(tmp_packed1&BEAM_TIGHT_MASK);
  Eterm src = yb((tmp_packed1>>BEAM_TIGHT_SHIFT));

  reg[live] = src;
  reg[live+1] = make_small(0);
  reg[live+2] = src;

  /* This instruction is always followed by i_length */
  SET_I(I+1);
  goto i_length_start__;

}

OpCase(i_loop_rec_f):
{

  /*
  * Pick up the next message and place it in x(0).
  * If no message, jump to a wait or wait_timeout instruction.
  */

  ErtsMessage* msgp;

  /* Entry point from recv_set */
  loop_rec_top__:

  /*
  * We need to disable GC while matching messages
  * in the queue. This since messages with data outside
  * the heap will be corrupted by a GC.
  */
  ASSERT(!(c_p->flags & F_DELAY_GC));
  c_p->flags |= F_DELAY_GC;

  /* Entry point from loop_rec_end (and locally) */
  loop_rec__:

  if (FCALLS <= 0 && FCALLS <= neg_o_reds) {
    c_p->i = I;
    ASSERT(VALID_INSTR(*c_p->i));;
    c_p->flags &= ~F_DELAY_GC;
    SWAPOUT;
    c_p->arity = 0;
    c_p->current = NULL;
    goto do_schedule;
  }

  ASSERT(!ERTS_PROC_IS_EXITING(c_p));

  PROCESS_MAIN_CHK_LOCKS(c_p);

  msgp = PEEK_MESSAGE(c_p);

  if (ERTS_UNLIKELY(msgp == NULL)) {
    int get_out;
    SWAPOUT;
    c_p->i = I;
    ASSERT(VALID_INSTR(*c_p->i));;
    c_p->arity = 0;
    c_p->current = NULL;
    c_p->fcalls = FCALLS;
    FCALLS -= erts_proc_sig_receive_helper(c_p, FCALLS, neg_o_reds,
    &msgp, &get_out);
    SWAPIN;
    if (ERTS_UNLIKELY(msgp == NULL)) {
      if (get_out) {
        if (get_out < 0) {
          ASSERT(FCALLS <= 0 && FCALLS <= neg_o_reds);
          goto loop_rec__; /* yield */
        }
        else {
          ASSERT(ERTS_PROC_IS_EXITING(c_p));
          goto do_schedule; /* exit */
        }
      }

      /*
      * If there are no more messages in queue
      * (and we are not yielding or exiting)
      * erts_proc_sig_receive_helper()
      * returns with message queue lock locked...
      */
      c_p->flags &= ~F_DELAY_GC;
      ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
      I += fb(BeamExtraData(I[0])) + 0;;
      Goto(*I);		/* Jump to a wait or wait_timeout instruction */
    }
  }

  ASSERT(msgp == PEEK_MESSAGE(c_p));
  ASSERT(msgp && ERTS_SIG_IS_MSG(msgp));

  if (ERTS_UNLIKELY(ERTS_SIG_IS_EXTERNAL_MSG(msgp))) {
    FCALLS -= 10; /* FIXME: bump appropriate amount... */
    SWAPOUT; /* erts_proc_sig_decode_dist() may write to heap... */
    if (!erts_proc_sig_decode_dist(c_p, ERTS_PROC_LOCK_MAIN, msgp, 0)) {
      /*
      * A corrupt distribution message that we weren't able to decode;
      * remove it...
      */
      /* No swapin should be needed */
      ASSERT(HTOP == c_p->htop && E == c_p->stop);
      /* TODO: Add DTrace probe for this bad message situation? */
      UNLINK_MESSAGE(c_p, msgp);
      msgp->next = NULL;
      erts_cleanup_messages(msgp);
      goto loop_rec__;
    }
    SWAPIN;
  }

  ASSERT(msgp == PEEK_MESSAGE(c_p));
  ASSERT(ERTS_SIG_IS_INTERNAL_MSG(msgp));

  r(0) = ERL_MESSAGE_TERM(msgp);
  I += 1;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(i_m_div_jssd):
{
  Eterm targ1;
  Eterm targ2;
  Eterm dst = I[3];
  Eterm* dst_ptr = REG_TARGET_PTR(dst);
  GetSource(I[1], targ1);
  GetSource(I[2], targ2);
  {
    Eterm op1 = targ1;
    Eterm op2 = targ2;
    do {
      Eterm result;
#ifdef DEBUG
      Eterm* orig_htop = HTOP;
      Eterm* orig_stop = E;
#endif
      DEBUG_SWAPOUT;
      result = erts_mixed_div (c_p, op1, op2);
      DEBUG_SWAPIN;
      ASSERT(orig_htop == HTOP && orig_stop == E);
      ERTS_HOLE_CHECK(c_p);
      if (ERTS_LIKELY(is_value(result))) {
        *dst_ptr = result;
        SET_I((BeamInstr *) I+4);
        Goto(*I);;
      }
      if (ERTS_LIKELY(jb(BeamExtraData(I[0])))) {
        ASSERT(VALID_INSTR(*(I + (jb(BeamExtraData(I[0]))) + 0)));
        I += jb(BeamExtraData(I[0])) + 0;;
        Goto(*I);;
      }
      reg[0] = op1;
      reg[1] = op2;
      SWAPOUT;
      I = handle_error(c_p, I, reg, &bif_export[BIF_div_2]->info.mfa);
      goto post_error_handling;;
    } while (0);
  }
}

{
  Eterm MinusOp1, MinusOp2;
  OpCase(i_minus_cxjd):
  {
    MinusOp1 = I[1];
    MinusOp2 = xb(BeamExtraData(I[0]));
  }
  I += 1;
  goto minus__execute;

  OpCase(i_minus_cyjd):
  {
    MinusOp1 = I[1];
    MinusOp2 = yb(BeamExtraData(I[0]));
  }
  I += 1;
  goto minus__execute;

  OpCase(i_minus_xxjd):
  {
    Eterm tmp_packed1 = BeamExtraData(I[0]);
    MinusOp1 = xb(tmp_packed1&BEAM_TIGHT_MASK);
    MinusOp2 = xb((tmp_packed1>>BEAM_TIGHT_SHIFT));
  }
  goto minus__execute;

  OpCase(i_minus_xyjd):
  {
    Eterm tmp_packed1 = BeamExtraData(I[0]);
    MinusOp1 = xb(tmp_packed1&BEAM_TIGHT_MASK);
    MinusOp2 = yb((tmp_packed1>>BEAM_TIGHT_SHIFT));
  }
  goto minus__execute;

  OpCase(i_minus_yxjd):
  {
    Eterm tmp_packed1 = BeamExtraData(I[0]);
    MinusOp1 = yb(tmp_packed1&BEAM_TIGHT_MASK);
    MinusOp2 = xb((tmp_packed1>>BEAM_TIGHT_SHIFT));
  }
  goto minus__execute;

  OpCase(i_minus_yyjd):
  {
    Eterm tmp_packed1 = BeamExtraData(I[0]);
    MinusOp1 = yb(tmp_packed1&BEAM_TIGHT_MASK);
    MinusOp2 = yb((tmp_packed1>>BEAM_TIGHT_SHIFT));
  }
  goto minus__execute;

  minus__execute:
  {
    Eterm tmp_packed1 = I[1];
    Eterm dst = db((tmp_packed1>>BEAM_WIDE_SHIFT));
    Eterm* dst_ptr = REG_TARGET_PTR(dst);
    if (ERTS_LIKELY(is_both_small(MinusOp1, MinusOp2))) {
#ifdef HAVE_OVERFLOW_CHECK_BUILTINS
      Sint lhs_tagged, rhs_untagged, res;

      /* See plus.execute */
      lhs_tagged = MinusOp1;
      rhs_untagged = MinusOp2 & ~_TAG_IMMED1_MASK;

      if (ERTS_LIKELY(!__builtin_sub_overflow(lhs_tagged, rhs_untagged, &res))) {
        ASSERT(is_small(res));
        *dst_ptr = res;
        SET_I((BeamInstr *) I+2);
        Goto(*I);;
      }
#else
      Sint i = signed_val(MinusOp1) - signed_val(MinusOp2);

      if (ERTS_LIKELY(IS_SSMALL(i))) {
        *dst_ptr = make_small(i);
        SET_I((BeamInstr *) I+2);
        Goto(*I);;
      }
#endif
    }
    do {
      Eterm result;
#ifdef DEBUG
      Eterm* orig_htop = HTOP;
      Eterm* orig_stop = E;
#endif
      DEBUG_SWAPOUT;
      result = erts_mixed_minus (c_p, MinusOp1, MinusOp2);
      DEBUG_SWAPIN;
      ASSERT(orig_htop == HTOP && orig_stop == E);
      ERTS_HOLE_CHECK(c_p);
      if (ERTS_LIKELY(is_value(result))) {
        *dst_ptr = result;
        SET_I((BeamInstr *) I+2);
        Goto(*I);;
      }
      if (ERTS_LIKELY(jb(tmp_packed1&BEAM_WIDE_MASK))) {
        ASSERT(VALID_INSTR(*(I + (jb(tmp_packed1&BEAM_WIDE_MASK)) + 0)));
        I += jb(tmp_packed1&BEAM_WIDE_MASK) + 0;;
        Goto(*I);;
      }
      reg[0] = MinusOp1;
      reg[1] = MinusOp2;
      SWAPOUT;
      I = handle_error(c_p, I, reg, &bif_export[BIF_sminus_2]->info.mfa);
      goto post_error_handling;;
    } while (0);
  }

}

OpCase(i_move_call_ext_ce):
{
  x(0) = I[1];
  SET_CP(c_p, I+3);
  DTRACE_GLOBAL_CALL_FROM_EXPORT(c_p, I[2]);
  // Dispatchx assumes the Export* is in Arg(0)
  I = (&I[2]) - 1;
  Dispatchx();;;
}

OpCase(i_move_call_ext_last_eQc):
{
  x(0) = I[2];
  SET_CP(c_p, (BeamInstr *) cp_val(*E));
  E = ADD_BYTE_OFFSET(E, Qb(BeamExtraData(I[0])));;
  DTRACE_GLOBAL_CALL_FROM_EXPORT(c_p, I[1]);
  // Dispatchx assumes the Export* is in Arg(0)
  I = (&I[1]) - 1;
  Dispatchx();;;
}

OpCase(i_move_call_ext_only_ec):
{
  x(0) = I[2];
  DTRACE_GLOBAL_CALL_FROM_EXPORT(c_p, I[1]);
  // Dispatchx assumes the Export* is in Arg(0)
  I = (&I[1]) - 1;
  Dispatchx();;;
}

OpCase(i_new_small_map_lit_dtq):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  Eterm dst = db(tmp_packed1&BEAM_TIGHT_MASK);
  Eterm* dst_ptr = REG_TARGET_PTR(dst);
  Eterm res;
  Uint n;
  Eterm keys = I[1];

  HEAVY_SWAPOUT;
  res = erts_gc_new_small_map_lit(c_p, reg, keys, tb((tmp_packed1>>BEAM_TIGHT_SHIFT)), I+2);
  HEAVY_SWAPIN;
  dst_ptr = REG_TARGET_PTR(dst);
  *dst_ptr = res;
  n = arityval(*tuple_val(keys));
  SET_I((BeamInstr *) I+2+n);
  Goto(*I);;
}

{
  Eterm PlusOp1, PlusOp2;
  OpCase(i_plus_xcjd):
  {
    PlusOp1 = xb(BeamExtraData(I[0]));
    PlusOp2 = I[1];
  }
  I += 1;
  goto plus__execute;

  OpCase(i_plus_xxjd):
  {
    Eterm tmp_packed1 = BeamExtraData(I[0]);
    PlusOp1 = xb(tmp_packed1&BEAM_TIGHT_MASK);
    PlusOp2 = xb((tmp_packed1>>BEAM_TIGHT_SHIFT));
  }
  goto plus__execute;

  OpCase(i_plus_xyjd):
  {
    Eterm tmp_packed1 = BeamExtraData(I[0]);
    PlusOp1 = xb(tmp_packed1&BEAM_TIGHT_MASK);
    PlusOp2 = yb((tmp_packed1>>BEAM_TIGHT_SHIFT));
  }
  goto plus__execute;

  OpCase(i_plus_ycjd):
  {
    PlusOp1 = yb(BeamExtraData(I[0]));
    PlusOp2 = I[1];
  }
  I += 1;
  goto plus__execute;

  OpCase(i_plus_yxjd):
  {
    Eterm tmp_packed1 = BeamExtraData(I[0]);
    PlusOp1 = yb(tmp_packed1&BEAM_TIGHT_MASK);
    PlusOp2 = xb((tmp_packed1>>BEAM_TIGHT_SHIFT));
  }
  goto plus__execute;

  OpCase(i_plus_yyjd):
  {
    Eterm tmp_packed1 = BeamExtraData(I[0]);
    PlusOp1 = yb(tmp_packed1&BEAM_TIGHT_MASK);
    PlusOp2 = yb((tmp_packed1>>BEAM_TIGHT_SHIFT));
  }
  goto plus__execute;

  plus__execute:
  {
    Eterm tmp_packed1 = I[1];
    Eterm dst = db((tmp_packed1>>BEAM_WIDE_SHIFT));
    Eterm* dst_ptr = REG_TARGET_PTR(dst);
    if (ERTS_LIKELY(is_both_small(PlusOp1, PlusOp2))) {
#ifdef HAVE_OVERFLOW_CHECK_BUILTINS
      Sint lhs_tagged, rhs_untagged, res;

      /* The value part of immediate integers start right after the tag and
      * occupy the rest of the word, so if you squint a bit they look like
      * fixed-point integers; as long as you mask the tag away you will get
      * correct results from addition/subtraction since they share the same
      * notion of zero. It's fairly easy to see that the following holds
      * when (a + b) is in range:
      *
      *     (a >> s) + (b >> s) == ((a & ~m) + (b & ~m)) >> s
      *
      * Where 's' is the tag size and 'm' is the tag mask.
      *
      * The left-hand side is our fallback in the #else clause and is the
      * fastest way to do this safely in plain C. The actual addition will
      * never overflow since `Sint` has a much greater range than our
      * smalls, so we can use the IS_SSMALL macro to see if the result is
      * within range.
      *
      * What we're doing below is an extension of the right-hand side. By
      * treating `a` and `b` as fixed-point integers, all additions whose
      * result is out of range will also overflow `Sint` and we can use the
      * compiler's overflow intrinsics to check for this condition.
      *
      * In addition, since the tag lives in the lowest bits we can further
      * optimize this by only stripping the tag from either side. The higher
      * bits can't influence the tag bits since we bail on overflow, so the
      * tag bits from the tagged side will simply appear in the result. */
      lhs_tagged = PlusOp1;
      rhs_untagged = PlusOp2 & ~_TAG_IMMED1_MASK;

      if (ERTS_LIKELY(!__builtin_add_overflow(lhs_tagged, rhs_untagged, &res))) {
        ASSERT(is_small(res));
        *dst_ptr = res;
        SET_I((BeamInstr *) I+2);
        Goto(*I);;
      }
#else
      Sint i = signed_val(PlusOp1) + signed_val(PlusOp2);
      if (ERTS_LIKELY(IS_SSMALL(i))) {
        *dst_ptr = make_small(i);
        SET_I((BeamInstr *) I+2);
        Goto(*I);;
      }
#endif
    }
    do {
      Eterm result;
#ifdef DEBUG
      Eterm* orig_htop = HTOP;
      Eterm* orig_stop = E;
#endif
      DEBUG_SWAPOUT;
      result = erts_mixed_plus (c_p, PlusOp1, PlusOp2);
      DEBUG_SWAPIN;
      ASSERT(orig_htop == HTOP && orig_stop == E);
      ERTS_HOLE_CHECK(c_p);
      if (ERTS_LIKELY(is_value(result))) {
        *dst_ptr = result;
        SET_I((BeamInstr *) I+2);
        Goto(*I);;
      }
      if (ERTS_LIKELY(jb(tmp_packed1&BEAM_WIDE_MASK))) {
        ASSERT(VALID_INSTR(*(I + (jb(tmp_packed1&BEAM_WIDE_MASK)) + 0)));
        I += jb(tmp_packed1&BEAM_WIDE_MASK) + 0;;
        Goto(*I);;
      }
      reg[0] = PlusOp1;
      reg[1] = PlusOp2;
      SWAPOUT;
      I = handle_error(c_p, I, reg, &bif_export[BIF_splus_2]->info.mfa);
      goto post_error_handling;;
    } while (0);
  }

}

OpCase(i_recv_mark):
{
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  /*
  * Save the current end of message queue
  */
  ERTS_RECV_MARK_SAVE(c_p);
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(i_recv_set):
{
  /*
  * If previously saved recv mark, set peek position to it
  */
  ERTS_RECV_MARK_SET(c_p);
  SET_I(I+1);
  goto loop_rec_top__;

}

{
  Eterm RemOp1, RemOp2;
  OpCase(i_rem_ssjd):
  {
    Eterm targ1;
    Eterm targ2;
    GetSource(I[1], targ1);
    GetSource(I[2], targ2);
    {
      RemOp1 = targ1;
      RemOp2 = targ2;
    }
  }
  I += 2;
  goto rem__execute;

  OpCase(i_rem_xxjd):
  {
    Eterm tmp_packed1 = BeamExtraData(I[0]);
    RemOp1 = xb(tmp_packed1&BEAM_TIGHT_MASK);
    RemOp2 = xb((tmp_packed1>>BEAM_TIGHT_SHIFT));
  }
  goto rem__execute;

  rem__execute:
  {
    Eterm tmp_packed1 = I[1];
    Eterm dst = db((tmp_packed1>>BEAM_WIDE_SHIFT));
    Eterm* dst_ptr = REG_TARGET_PTR(dst);
    if (ERTS_UNLIKELY(RemOp2 == SMALL_ZERO)) {
      c_p->freason = BADARITH;
      if (ERTS_LIKELY(jb(tmp_packed1&BEAM_WIDE_MASK))) {
        ASSERT(VALID_INSTR(*(I + (jb(tmp_packed1&BEAM_WIDE_MASK)) + 0)));
        I += jb(tmp_packed1&BEAM_WIDE_MASK) + 0;;
        Goto(*I);;
      }
      reg[0] = RemOp1;
      reg[1] = RemOp2;
      SWAPOUT;
      I = handle_error(c_p, I, reg, &bif_export[BIF_rem_2]->info.mfa);
      goto post_error_handling;;
    } else if (ERTS_LIKELY(is_both_small(RemOp1, RemOp2))) {
      *dst_ptr = make_small(signed_val(RemOp1) % signed_val(RemOp2));
      SET_I((BeamInstr *) I+2);
      Goto(*I);;
    } else {
      do {
        Eterm result;
#ifdef DEBUG
        Eterm* orig_htop = HTOP;
        Eterm* orig_stop = E;
#endif
        DEBUG_SWAPOUT;
        result = erts_int_rem (c_p, RemOp1, RemOp2);
        DEBUG_SWAPIN;
        ASSERT(orig_htop == HTOP && orig_stop == E);
        ERTS_HOLE_CHECK(c_p);
        if (ERTS_LIKELY(is_value(result))) {
          *dst_ptr = result;
          SET_I((BeamInstr *) I+2);
          Goto(*I);;
        }
        if (ERTS_LIKELY(jb(tmp_packed1&BEAM_WIDE_MASK))) {
          ASSERT(VALID_INSTR(*(I + (jb(tmp_packed1&BEAM_WIDE_MASK)) + 0)));
          I += jb(tmp_packed1&BEAM_WIDE_MASK) + 0;;
          Goto(*I);;
        }
        reg[0] = RemOp1;
        reg[1] = RemOp2;
        SWAPOUT;
        I = handle_error(c_p, I, reg, &bif_export[BIF_rem_2]->info.mfa);
        goto post_error_handling;;
      } while (0);
    }
  }

}

{
  Eterm select_val2;
  OpCase(i_select_tuple_arity2_xfAA):
  {
    select_val2 = xb(BeamExtraData(I[0]));
  }
  goto select_val2__get_arity;

  OpCase(i_select_tuple_arity2_yfAA):
  {
    select_val2 = yb(BeamExtraData(I[0]));
  }
  goto select_val2__get_arity;

  OpCase(i_select_val2_xfcc):
  {
    select_val2 = xb(BeamExtraData(I[0]));
  }
  goto select_val2__execute;

  OpCase(i_select_val2_yfcc):
  {
    select_val2 = yb(BeamExtraData(I[0]));
  }
  goto select_val2__execute;

  select_val2__get_arity:
  {
    if (ERTS_LIKELY(is_tuple(select_val2))) {
      select_val2 = *tuple_val(select_val2);
    } else {
      select_val2 = NIL;
    }
  }
  goto select_val2__execute;

  select_val2__execute:
  {
    Sint32* jump_tab = (Sint32 *) (I+4);

    if (select_val2 == I[2]) {
      ASSERT(VALID_INSTR(*(I + (jump_tab[0]) + 0)));
      I += jump_tab[0] + 0;;
      Goto(*I);;
    } else if (select_val2 == I[3]) {
      ASSERT(VALID_INSTR(*(I + (jump_tab[1]) + 0)));
      I += jump_tab[1] + 0;;
      Goto(*I);;
    } else {
      ASSERT(VALID_INSTR(*(I + (I[1]) + 0)));
      I += I[1] + 0;;
      Goto(*I);;
    }
  }

}

{
  Eterm select_val;
  OpCase(i_select_tuple_arity_xfI):
  {
    select_val = xb(BeamExtraData(I[0]));
  }
  goto select_val_lin__get_arity;

  OpCase(i_select_tuple_arity_yfI):
  {
    select_val = yb(BeamExtraData(I[0]));
  }
  goto select_val_lin__get_arity;

  OpCase(i_select_val_lins_xfI):
  {
    select_val = xb(BeamExtraData(I[0]));
  }
  goto select_val_lin__execute;

  OpCase(i_select_val_lins_yfI):
  {
    select_val = yb(BeamExtraData(I[0]));
  }
  goto select_val_lin__execute;

  select_val_lin__get_arity:
  {
    if (ERTS_LIKELY(is_tuple(select_val))) {
      select_val = *tuple_val(select_val);
    } else {
      select_val = NIL;
    }
  }
  goto select_val_lin__execute;

  select_val_lin__execute:
  {
    Eterm tmp_packed1 = I[1];
    BeamInstr* vs = I+2;
    int ix = 0;

    for (;;) {
      if (vs[ix+0] >= select_val) {
        ix += 0;
        break;
      }
      if (vs[ix+1] >= select_val) {
        ix += 1;
        break;
      }
      ix += 2;
    }

    if (vs[ix] == select_val) {
      Sint32* jump_tab = (Sint32 *) (I+2 + Ib((tmp_packed1>>BEAM_WIDE_SHIFT)));
      Eterm offset = jump_tab[ix];
      ASSERT(VALID_INSTR(*(I + (offset) + 0)));
      I += offset + 0;;
      Goto(*I);;
    } else {
      ASSERT(VALID_INSTR(*(I + (fb(tmp_packed1&BEAM_WIDE_MASK)) + 0)));
      I += fb(tmp_packed1&BEAM_WIDE_MASK) + 0;;
      Goto(*I);;
    }
  }

}

{
  Eterm select_val;
  OpCase(i_select_val_bins_xfI):
  {
    select_val = xb(BeamExtraData(I[0]));
  }
  goto select_val_bins__select;

  OpCase(i_select_val_bins_yfI):
  {
    select_val = yb(BeamExtraData(I[0]));
  }
  goto select_val_bins__select;

  select_val_bins__select:
  {
    Eterm tmp_packed1 = I[1];
    struct Singleton {
      BeamInstr val;
    };
    struct Singleton* low;
    struct Singleton* high;
    struct Singleton* mid;
    int bdiff; /* int not long because the arrays aren't that large */

    low = (struct Singleton *) (I+2);
    high = low + Ib((tmp_packed1>>BEAM_WIDE_SHIFT));

    /* The pointer subtraction (high-low) below must produce
    * a signed result, because high could be < low. That
    * requires the compiler to insert quite a bit of code.
    *
    * However, high will be > low so the result will be
    * positive. We can use that knowledge to optimise the
    * entire sequence, from the initial comparison to the
    * computation of mid.
    *
    * -- Mikael Pettersson, Acumem AB
    *
    * Original loop control code:
    *
    * while (low < high) {
      *    mid = low + (high-low) / 2;
      *
      */
      while ((bdiff = (int)((char*)high - (char*)low)) > 0) {
        unsigned int boffset = ((unsigned int)bdiff >> 1) & ~(sizeof(struct Singleton)-1);

        mid = (struct Singleton*)((char*)low + boffset);
        if (select_val < mid->val) {
          high = mid;
        } else if (select_val > mid->val) {
          low = mid + 1;
        } else {
          Sint32* jump_tab = (Sint32 *) (I+2 + Ib((tmp_packed1>>BEAM_WIDE_SHIFT)));
          Sint32 offset = jump_tab[mid - (struct Singleton *)(I+2)];
          ASSERT(VALID_INSTR(*(I + (offset) + 0)));
          I += offset + 0;;
          Goto(*I);;
        }
      }
      ASSERT(VALID_INSTR(*(I + (fb(tmp_packed1&BEAM_WIDE_MASK)) + 0)));
      I += fb(tmp_packed1&BEAM_WIDE_MASK) + 0;;
      Goto(*I);;
    }

  }

OpCase(i_times_jssd):
{
  Eterm targ1;
  Eterm targ2;
  Eterm dst = I[3];
  Eterm* dst_ptr = REG_TARGET_PTR(dst);
  GetSource(I[1], targ1);
  GetSource(I[2], targ2);
  {
    Eterm op1 = targ1;
    Eterm op2 = targ2;
#ifdef HAVE_OVERFLOW_CHECK_BUILTINS
    if (ERTS_LIKELY(is_both_small(op1, op2))) {
      /* See plus.execute */
      Sint lhs_untagged, rhs_actual, res;

      lhs_untagged = op1 & ~_TAG_IMMED1_MASK;
      rhs_actual = signed_val(op2);

      if (ERTS_LIKELY(!__builtin_mul_overflow(lhs_untagged, rhs_actual, &res))) {
        ASSERT(!(res & _TAG_IMMED1_MASK));
        *dst_ptr = res | _TAG_IMMED1_SMALL;
        SET_I((BeamInstr *) I+4);
        Goto(*I);;
      }
    }
#endif
    do {
      Eterm result;
#ifdef DEBUG
      Eterm* orig_htop = HTOP;
      Eterm* orig_stop = E;
#endif
      DEBUG_SWAPOUT;
      result = erts_mixed_times (c_p, op1, op2);
      DEBUG_SWAPIN;
      ASSERT(orig_htop == HTOP && orig_stop == E);
      ERTS_HOLE_CHECK(c_p);
      if (ERTS_LIKELY(is_value(result))) {
        *dst_ptr = result;
        SET_I((BeamInstr *) I+4);
        Goto(*I);;
      }
      if (ERTS_LIKELY(jb(BeamExtraData(I[0])))) {
        ASSERT(VALID_INSTR(*(I + (jb(BeamExtraData(I[0]))) + 0)));
        I += jb(BeamExtraData(I[0])) + 0;;
        Goto(*I);;
      }
      reg[0] = op1;
      reg[1] = op2;
      SWAPOUT;
      I = handle_error(c_p, I, reg, &bif_export[BIF_stimes_2]->info.mfa);
      goto post_error_handling;;
    } while (0);
  }
}

OpCase(i_trim_t):
{
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  Uint cp = E[0];
  E += tb(BeamExtraData(I[0]));
  E[0] = cp;
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(init2_yy):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  make_blank(yb(tmp_packed1&BEAM_TIGHT_MASK));
  make_blank(yb((tmp_packed1>>BEAM_TIGHT_SHIFT)));
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(init3_yyy):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  make_blank(y(tmp_packed1&BEAM_TIGHTEST_MASK));
  make_blank(y((tmp_packed1>>BEAM_TIGHTEST_SHIFT)&BEAM_TIGHTEST_MASK));
  make_blank(y((tmp_packed1>>(2*BEAM_TIGHTEST_SHIFT))));
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(init_seq3_y):
{
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  Eterm* dst = &yb(BeamExtraData(I[0]));
  make_blank(dst[0]);
  make_blank(dst[1]);
  make_blank(dst[2]);
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(init_seq4_y):
{
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  Eterm* dst = &yb(BeamExtraData(I[0]));
  make_blank(dst[0]);
  make_blank(dst[1]);
  make_blank(dst[2]);
  make_blank(dst[3]);
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(init_seq5_y):
{
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  Eterm* dst = &yb(BeamExtraData(I[0]));
  make_blank(dst[0]);
  make_blank(dst[1]);
  make_blank(dst[2]);
  make_blank(dst[3]);
  make_blank(dst[4]);
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(init_y):
{
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  make_blank(yb(BeamExtraData(I[0])));
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(is_atom_fx):
{
  if (is_not_atom(xb(I[1]))) {
    ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
    I += fb(BeamExtraData(I[0])) + 0;;
    Goto(*I);;
  }
  I += 2;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_binary_fx):
{
  if (is_not_binary(xb(I[1])) || binary_bitsize(xb(I[1])) != 0) {
    ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
    I += fb(BeamExtraData(I[0])) + 0;;
    Goto(*I);;
  }
  I += 2;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_bitstring_fx):
{
  if (is_not_binary(xb(I[1]))) {
    ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
    I += fb(BeamExtraData(I[0])) + 0;;
    Goto(*I);;
  }
  I += 2;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_eq_exact_fxx):
{
  Eterm tmp_packed2 = I[1];
  if (!EQ(xb(tmp_packed2&BEAM_LOOSE_MASK), xb((tmp_packed2>>BEAM_LOOSE_SHIFT)))) {
    ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
    I += fb(BeamExtraData(I[0])) + 0;;
    Goto(*I);;
  }
  I += 2;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_eq_exact_fxy):
{
  Eterm tmp_packed2 = I[1];
  if (!EQ(xb(tmp_packed2&BEAM_LOOSE_MASK), yb((tmp_packed2>>BEAM_LOOSE_SHIFT)))) {
    ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
    I += fb(BeamExtraData(I[0])) + 0;;
    Goto(*I);;
  }
  I += 2;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_eq_exact_fyy):
{
  Eterm tmp_packed2 = I[1];
  if (!EQ(yb(tmp_packed2&BEAM_LOOSE_MASK), yb((tmp_packed2>>BEAM_LOOSE_SHIFT)))) {
    ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
    I += fb(BeamExtraData(I[0])) + 0;;
    Goto(*I);;
  }
  I += 2;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_eq_fSs):
{
  Eterm targ1;
  GetSource(I[2], targ1);
  {
    Eterm a = Sb(I[1]);
    Eterm b = targ1;
    CMP_EQ_ACTION(a, b, ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
    I += fb(BeamExtraData(I[0])) + 0;;
    Goto(*I););
    I += 3;
    ASSERT(VALID_INSTR(*I));
    Goto(*I);
  }
}

OpCase(is_float_fx):
{
  if (is_not_float(xb(I[1]))) {
    ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
    I += fb(BeamExtraData(I[0])) + 0;;
    Goto(*I);;
  }
  I += 2;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_function_fx):
{
  if ( !(is_any_fun(xb(I[1]))) ) {
    ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
    I += fb(BeamExtraData(I[0])) + 0;;
    Goto(*I);;
  }
  I += 2;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_function_fy):
{
  if ( !(is_any_fun(yb(I[1]))) ) {
    ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
    I += fb(BeamExtraData(I[0])) + 0;;
    Goto(*I);;
  }
  I += 2;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_ge_fcx):
{
  CMP_GE_ACTION(I[1], xb(I[2]), ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
  I += fb(BeamExtraData(I[0])) + 0;;
  Goto(*I););
  I += 3;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_ge_fxc):
{
  CMP_GE_ACTION(xb(I[1]), I[2], ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
  I += fb(BeamExtraData(I[0])) + 0;;
  Goto(*I););
  I += 3;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_ge_fxx):
{
  Eterm tmp_packed2 = I[1];
  CMP_GE_ACTION(xb(tmp_packed2&BEAM_LOOSE_MASK), xb((tmp_packed2>>BEAM_LOOSE_SHIFT)), ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
  I += fb(BeamExtraData(I[0])) + 0;;
  Goto(*I););
  I += 2;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_integer_allocate_fxtt):
{
  Eterm tmp_packed2 = I[1];
  if (is_not_integer(xb(tmp_packed2&BEAM_TIGHT_MASK))) {
    ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
    I += fb(BeamExtraData(I[0])) + 0;;
    Goto(*I);;
  };
  do {
    unsigned needed = tb((tmp_packed2>>BEAM_TIGHT_SHIFT)&BEAM_TIGHT_MASK) + 1;
    do {
      Uint need = 0 + needed;
      if (ERTS_UNLIKELY(E - HTOP < need)) {
        do {
          //
          // Since a garbage collection is expensive anyway, we can afford
          // to save the instruction counter so that the correct function will
          // be pointed in the crash dump if the garbage collection fails
          // because of insufficient memory.
          //
          SWAPOUT;
          c_p->i = I;
        } while (0);
        PROCESS_MAIN_CHK_LOCKS(c_p);
        FCALLS -= erts_garbage_collect_nobump(c_p, need, reg, tb((tmp_packed2>>(2*BEAM_TIGHT_SHIFT))), FCALLS);
        ERTS_VERIFY_UNUSED_TEMP_ALLOC(c_p);
        PROCESS_MAIN_CHK_LOCKS(c_p);
        SWAPIN;
      }
      HEAP_SPACE_VERIFIED(0);
    } while (0);
    E -= needed;
    *E = make_cp(c_p->cp);
    c_p->cp = 0;
  } while (0);
  I += 2;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_integer_fx):
{
  if (is_not_integer(xb(I[1]))) {
    ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
    I += fb(BeamExtraData(I[0])) + 0;;
    Goto(*I);;
  }
  I += 2;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_integer_fy):
{
  if (is_not_integer(yb(I[1]))) {
    ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
    I += fb(BeamExtraData(I[0])) + 0;;
    Goto(*I);;
  }
  I += 2;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_list_fx):
{
  if (is_not_list(xb(I[1])) && is_not_nil(xb(I[1]))) {
    ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
    I += fb(BeamExtraData(I[0])) + 0;;
    Goto(*I);;
  }
  I += 2;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_lt_fcx):
{
  CMP_LT_ACTION(I[1], xb(I[2]), ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
  I += fb(BeamExtraData(I[0])) + 0;;
  Goto(*I););
  I += 3;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_lt_fxc):
{
  CMP_LT_ACTION(xb(I[1]), I[2], ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
  I += fb(BeamExtraData(I[0])) + 0;;
  Goto(*I););
  I += 3;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_lt_fxx):
{
  Eterm tmp_packed2 = I[1];
  CMP_LT_ACTION(xb(tmp_packed2&BEAM_LOOSE_MASK), xb((tmp_packed2>>BEAM_LOOSE_SHIFT)), ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
  I += fb(BeamExtraData(I[0])) + 0;;
  Goto(*I););
  I += 2;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_map_fx):
{
  if (is_not_map(xb(I[1]))) {
    ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
    I += fb(BeamExtraData(I[0])) + 0;;
    Goto(*I);;
  }
  I += 2;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_map_fy):
{
  if (is_not_map(yb(I[1]))) {
    ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
    I += fb(BeamExtraData(I[0])) + 0;;
    Goto(*I);;
  }
  I += 2;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_ne_exact_fSS):
{
  Eterm tmp_packed2 = I[1];
  if (EQ(Sb(tmp_packed2&BEAM_LOOSE_MASK), Sb((tmp_packed2>>BEAM_LOOSE_SHIFT)))) {
    ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
    I += fb(BeamExtraData(I[0])) + 0;;
    Goto(*I);;
  }
  I += 2;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_ne_fSs):
{
  Eterm targ1;
  GetSource(I[2], targ1);
  {
    Eterm a = Sb(I[1]);
    Eterm b = targ1;
    CMP_NE_ACTION(a, b, ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
    I += fb(BeamExtraData(I[0])) + 0;;
    Goto(*I););
    I += 3;
    ASSERT(VALID_INSTR(*I));
    Goto(*I);
  }
}

OpCase(is_nil_fx):
{
  if (is_not_nil(xb(I[1]))) {
    ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
    I += fb(BeamExtraData(I[0])) + 0;;
    Goto(*I);;
  }
  I += 2;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_nil_fy):
{
  if (is_not_nil(yb(I[1]))) {
    ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
    I += fb(BeamExtraData(I[0])) + 0;;
    Goto(*I);;
  }
  I += 2;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_nonempty_list_allocate_frtt):
{
  Eterm tmp_packed2 = I[1];
  if (is_not_list(r(0))) {
    ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
    I += fb(BeamExtraData(I[0])) + 0;;
    Goto(*I);;
  };
  do {
    unsigned needed = tb(tmp_packed2&BEAM_LOOSE_MASK) + 1;
    do {
      Uint need = 0 + needed;
      if (ERTS_UNLIKELY(E - HTOP < need)) {
        do {
          //
          // Since a garbage collection is expensive anyway, we can afford
          // to save the instruction counter so that the correct function will
          // be pointed in the crash dump if the garbage collection fails
          // because of insufficient memory.
          //
          SWAPOUT;
          c_p->i = I;
        } while (0);
        PROCESS_MAIN_CHK_LOCKS(c_p);
        FCALLS -= erts_garbage_collect_nobump(c_p, need, reg, tb((tmp_packed2>>BEAM_LOOSE_SHIFT)), FCALLS);
        ERTS_VERIFY_UNUSED_TEMP_ALLOC(c_p);
        PROCESS_MAIN_CHK_LOCKS(c_p);
        SWAPIN;
      }
      HEAP_SPACE_VERIFIED(0);
    } while (0);
    E -= needed;
    *E = make_cp(c_p->cp);
    c_p->cp = 0;
  } while (0);
  I += 2;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_nonempty_list_allocate_fxtt):
{
  Eterm tmp_packed2 = I[1];
  if (is_not_list(xb(tmp_packed2&BEAM_TIGHT_MASK))) {
    ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
    I += fb(BeamExtraData(I[0])) + 0;;
    Goto(*I);;
  };
  do {
    unsigned needed = tb((tmp_packed2>>BEAM_TIGHT_SHIFT)&BEAM_TIGHT_MASK) + 1;
    do {
      Uint need = 0 + needed;
      if (ERTS_UNLIKELY(E - HTOP < need)) {
        do {
          //
          // Since a garbage collection is expensive anyway, we can afford
          // to save the instruction counter so that the correct function will
          // be pointed in the crash dump if the garbage collection fails
          // because of insufficient memory.
          //
          SWAPOUT;
          c_p->i = I;
        } while (0);
        PROCESS_MAIN_CHK_LOCKS(c_p);
        FCALLS -= erts_garbage_collect_nobump(c_p, need, reg, tb((tmp_packed2>>(2*BEAM_TIGHT_SHIFT))), FCALLS);
        ERTS_VERIFY_UNUSED_TEMP_ALLOC(c_p);
        PROCESS_MAIN_CHK_LOCKS(c_p);
        SWAPIN;
      }
      HEAP_SPACE_VERIFIED(0);
    } while (0);
    E -= needed;
    *E = make_cp(c_p->cp);
    c_p->cp = 0;
  } while (0);
  I += 2;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_nonempty_list_fx):
{
  if (is_not_list(xb(I[1]))) {
    ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
    I += fb(BeamExtraData(I[0])) + 0;;
    Goto(*I);;
  }
  I += 2;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_nonempty_list_fy):
{
  if (is_not_list(yb(I[1]))) {
    ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
    I += fb(BeamExtraData(I[0])) + 0;;
    Goto(*I);;
  }
  I += 2;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_nonempty_list_get_hd_fxx):
{
  Eterm tmp_packed2 = I[1];
  if (is_not_list(xb(tmp_packed2&BEAM_LOOSE_MASK))) {
    ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
    I += fb(BeamExtraData(I[0])) + 0;;
    Goto(*I);;
  };
  do {
    Eterm* tmp_ptr = list_val(xb(tmp_packed2&BEAM_LOOSE_MASK));
    xb((tmp_packed2>>BEAM_LOOSE_SHIFT)) = CAR(tmp_ptr);
  } while (0);
  I += 2;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_nonempty_list_get_list_frxx):
{
  Eterm tmp_packed2 = I[1];
  if (is_not_list(r(0))) {
    ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
    I += fb(BeamExtraData(I[0])) + 0;;
    Goto(*I);;
  };
  do {
    Eterm* tmp_ptr = list_val(r(0));
    Eterm hd, tl;
    hd = CAR(tmp_ptr);
    tl = CDR(tmp_ptr);
    xb(tmp_packed2&BEAM_LOOSE_MASK) = hd;
    xb((tmp_packed2>>BEAM_LOOSE_SHIFT)) = tl;
  } while (0);
  I += 2;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_nonempty_list_get_list_fxxx):
{
  Eterm tmp_packed2 = I[1];
  if (is_not_list(xb(tmp_packed2&BEAM_TIGHT_MASK))) {
    ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
    I += fb(BeamExtraData(I[0])) + 0;;
    Goto(*I);;
  };
  do {
    Eterm* tmp_ptr = list_val(xb(tmp_packed2&BEAM_TIGHT_MASK));
    Eterm hd, tl;
    hd = CAR(tmp_ptr);
    tl = CDR(tmp_ptr);
    xb((tmp_packed2>>BEAM_TIGHT_SHIFT)&BEAM_TIGHT_MASK) = hd;
    xb((tmp_packed2>>(2*BEAM_TIGHT_SHIFT))) = tl;
  } while (0);
  I += 2;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_nonempty_list_get_tl_fxx):
{
  Eterm tmp_packed2 = I[1];
  if (is_not_list(xb(tmp_packed2&BEAM_LOOSE_MASK))) {
    ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
    I += fb(BeamExtraData(I[0])) + 0;;
    Goto(*I);;
  };
  do {
    Eterm* tmp_ptr = list_val(xb(tmp_packed2&BEAM_LOOSE_MASK));
    xb((tmp_packed2>>BEAM_LOOSE_SHIFT)) = CDR(tmp_ptr);
  } while (0);
  I += 2;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_pid_fx):
{
  if (is_not_pid(xb(I[1]))) {
    ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
    I += fb(BeamExtraData(I[0])) + 0;;
    Goto(*I);;
  }
  I += 2;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_port_fx):
{
  if (is_not_port(xb(I[1]))) {
    ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
    I += fb(BeamExtraData(I[0])) + 0;;
    Goto(*I);;
  }
  I += 2;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_reference_fx):
{
  if (is_not_ref(xb(I[1]))) {
    ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
    I += fb(BeamExtraData(I[0])) + 0;;
    Goto(*I);;
  }
  I += 2;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_tagged_tuple_ff_ffrAa):
{
  Eterm term = r(0);
  if (is_not_tuple(term)) {
    ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
    I += fb(BeamExtraData(I[0])) + 0;;
    Goto(*I);;
  } else if (ERTS_UNLIKELY((tuple_val(term))[0] != I[2] ||
  (tuple_val(term))[1] != I[3])) {
    ASSERT(VALID_INSTR(*(I + (I[1]) + 0)));
    I += I[1] + 0;;
    Goto(*I);;
  }
  I += 4;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_tagged_tuple_ff_ffxAa):
{
  Eterm term = xb(I[2]);
  if (is_not_tuple(term)) {
    ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
    I += fb(BeamExtraData(I[0])) + 0;;
    Goto(*I);;
  } else if (ERTS_UNLIKELY((tuple_val(term))[0] != I[3] ||
  (tuple_val(term))[1] != I[4])) {
    ASSERT(VALID_INSTR(*(I + (I[1]) + 0)));
    I += I[1] + 0;;
    Goto(*I);;
  }
  I += 5;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_tagged_tuple_frAa):
{
  Eterm term = r(0);
  if (!(BEAM_IS_TUPLE(term) &&
  (tuple_val(term))[0] == I[1] &&
  (tuple_val(term))[1] == I[2])) {
    ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
    I += fb(BeamExtraData(I[0])) + 0;;
    Goto(*I);;
  }
  I += 3;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_tagged_tuple_fxAa):
{
  Eterm term = xb(I[1]);
  if (!(BEAM_IS_TUPLE(term) &&
  (tuple_val(term))[0] == I[2] &&
  (tuple_val(term))[1] == I[3])) {
    ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
    I += fb(BeamExtraData(I[0])) + 0;;
    Goto(*I);;
  }
  I += 4;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_tagged_tuple_fyAa):
{
  Eterm term = yb(I[1]);
  if (!(BEAM_IS_TUPLE(term) &&
  (tuple_val(term))[0] == I[2] &&
  (tuple_val(term))[1] == I[3])) {
    ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
    I += fb(BeamExtraData(I[0])) + 0;;
    Goto(*I);;
  }
  I += 4;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_tuple_fr):
{
  if (is_not_tuple(r(0))) {
    ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
    I += fb(BeamExtraData(I[0])) + 0;;
    Goto(*I);;
  }
  I += 1;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_tuple_fx):
{
  if (is_not_tuple(xb(I[1]))) {
    ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
    I += fb(BeamExtraData(I[0])) + 0;;
    Goto(*I);;
  }
  I += 2;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_tuple_fy):
{
  if (is_not_tuple(yb(I[1]))) {
    ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
    I += fb(BeamExtraData(I[0])) + 0;;
    Goto(*I);;
  }
  I += 2;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_tuple_of_arity_frA):
{
  Eterm term = r(0);
  if (!(BEAM_IS_TUPLE(term) && *tuple_val(term) == I[1])) {
    ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
    I += fb(BeamExtraData(I[0])) + 0;;
    Goto(*I);;
  }
  I += 2;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_tuple_of_arity_fxA):
{
  Eterm term = xb(I[1]);
  if (!(BEAM_IS_TUPLE(term) && *tuple_val(term) == I[2])) {
    ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
    I += fb(BeamExtraData(I[0])) + 0;;
    Goto(*I);;
  }
  I += 3;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(is_tuple_of_arity_fyA):
{
  Eterm term = yb(I[1]);
  if (!(BEAM_IS_TUPLE(term) && *tuple_val(term) == I[2])) {
    ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
    I += fb(BeamExtraData(I[0])) + 0;;
    Goto(*I);;
  }
  I += 3;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(jump_f):
{
  ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
  I += fb(BeamExtraData(I[0])) + 0;;
  Goto(*I);;
}

OpCase(loop_rec_end_f):
{
  /*
  * Advance the save pointer to the next message (the current
  * message didn't match), then jump to the loop_rec instruction.
  */

  ASSERT(c_p->flags & F_DELAY_GC);

  ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
  I += fb(BeamExtraData(I[0])) + 0;;
  SAVE_MESSAGE(c_p);
  FCALLS--;
  goto loop_rec__;
}

OpCase(move2_par_xxxx):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  Eterm V1, V2;
  V1 = xb(tmp_packed1&BEAM_LOOSE_MASK);
  V2 = xb((tmp_packed1>>(2*BEAM_LOOSE_SHIFT))&BEAM_LOOSE_MASK);
  xb((tmp_packed1>>BEAM_LOOSE_SHIFT)&BEAM_LOOSE_MASK) = V1;
  xb((tmp_packed1>>(3*BEAM_LOOSE_SHIFT))) = V2;
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(move2_par_xxxy):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  Eterm V1, V2;
  V1 = xb(tmp_packed1&BEAM_LOOSE_MASK);
  V2 = xb((tmp_packed1>>(2*BEAM_LOOSE_SHIFT))&BEAM_LOOSE_MASK);
  xb((tmp_packed1>>BEAM_LOOSE_SHIFT)&BEAM_LOOSE_MASK) = V1;
  yb((tmp_packed1>>(3*BEAM_LOOSE_SHIFT))) = V2;
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(move2_par_yxxx):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  Eterm V1, V2;
  V1 = yb(tmp_packed1&BEAM_LOOSE_MASK);
  V2 = xb((tmp_packed1>>(2*BEAM_LOOSE_SHIFT))&BEAM_LOOSE_MASK);
  xb((tmp_packed1>>BEAM_LOOSE_SHIFT)&BEAM_LOOSE_MASK) = V1;
  xb((tmp_packed1>>(3*BEAM_LOOSE_SHIFT))) = V2;
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(move2_par_yxxy):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  Eterm V1, V2;
  V1 = yb(tmp_packed1&BEAM_LOOSE_MASK);
  V2 = xb((tmp_packed1>>(2*BEAM_LOOSE_SHIFT))&BEAM_LOOSE_MASK);
  xb((tmp_packed1>>BEAM_LOOSE_SHIFT)&BEAM_LOOSE_MASK) = V1;
  yb((tmp_packed1>>(3*BEAM_LOOSE_SHIFT))) = V2;
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(move2_par_yxyx):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  Eterm V1, V2;
  V1 = yb(tmp_packed1&BEAM_LOOSE_MASK);
  V2 = yb((tmp_packed1>>(2*BEAM_LOOSE_SHIFT))&BEAM_LOOSE_MASK);
  xb((tmp_packed1>>BEAM_LOOSE_SHIFT)&BEAM_LOOSE_MASK) = V1;
  xb((tmp_packed1>>(3*BEAM_LOOSE_SHIFT))) = V2;
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(move3_xxxxxx):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  Eterm tmp_packed2 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  x((tmp_packed1>>BEAM_TIGHTEST_SHIFT)&BEAM_TIGHTEST_MASK) = x(tmp_packed1&BEAM_TIGHTEST_MASK);
  xb(tmp_packed2&BEAM_TIGHT_MASK) = x((tmp_packed1>>(2*BEAM_TIGHTEST_SHIFT)));
  xb((tmp_packed2>>(2*BEAM_TIGHT_SHIFT))) = xb((tmp_packed2>>BEAM_TIGHT_SHIFT)&BEAM_TIGHT_MASK);
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(move3_yxyxyx):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  Eterm tmp_packed2 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  x((tmp_packed1>>BEAM_TIGHTEST_SHIFT)&BEAM_TIGHTEST_MASK) = y(tmp_packed1&BEAM_TIGHTEST_MASK);
  xb(tmp_packed2&BEAM_TIGHT_MASK) = y((tmp_packed1>>(2*BEAM_TIGHTEST_SHIFT)));
  xb((tmp_packed2>>(2*BEAM_TIGHT_SHIFT))) = yb((tmp_packed2>>BEAM_TIGHT_SHIFT)&BEAM_TIGHT_MASK);
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(move_call_cf):
{
  x(0) = I[1];
  SET_CP(c_p, I+2);
  ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
  I += fb(BeamExtraData(I[0])) + 0;;
  DTRACE_LOCAL_CALL(c_p, erts_code_to_codemfa(I));
  Dispatch();;
}

OpCase(move_call_last_cfQ):
{
  x(0) = I[1];
  SET_CP(c_p, (BeamInstr *) cp_val(*E));
  E = ADD_BYTE_OFFSET(E, I[2]);;
  ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
  I += fb(BeamExtraData(I[0])) + 0;;
  DTRACE_LOCAL_CALL(c_p, erts_code_to_codemfa(I));
  Dispatch();;;
}

OpCase(move_call_last_xfQ):
{
  Eterm tmp_packed2 = I[1];
  x(0) = xb(BeamExtraData(I[0]));
  SET_CP(c_p, (BeamInstr *) cp_val(*E));
  E = ADD_BYTE_OFFSET(E, Qb((tmp_packed2>>BEAM_WIDE_SHIFT)));;
  ASSERT(VALID_INSTR(*(I + (fb(tmp_packed2&BEAM_WIDE_MASK)) + 0)));
  I += fb(tmp_packed2&BEAM_WIDE_MASK) + 0;;
  DTRACE_LOCAL_CALL(c_p, erts_code_to_codemfa(I));
  Dispatch();;;
}

OpCase(move_call_last_yfQ):
{
  Eterm tmp_packed2 = I[1];
  x(0) = yb(BeamExtraData(I[0]));
  SET_CP(c_p, (BeamInstr *) cp_val(*E));
  E = ADD_BYTE_OFFSET(E, Qb((tmp_packed2>>BEAM_WIDE_SHIFT)));;
  ASSERT(VALID_INSTR(*(I + (fb(tmp_packed2&BEAM_WIDE_MASK)) + 0)));
  I += fb(tmp_packed2&BEAM_WIDE_MASK) + 0;;
  DTRACE_LOCAL_CALL(c_p, erts_code_to_codemfa(I));
  Dispatch();;;
}

OpCase(move_call_only_cf):
{
  x(0) = I[1];
  ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
  I += fb(BeamExtraData(I[0])) + 0;;
  DTRACE_LOCAL_CALL(c_p, erts_code_to_codemfa(I));
  Dispatch();;;
}

OpCase(move_call_only_xf):
{
  x(0) = xb(BeamExtraData(I[0]));
  ASSERT(VALID_INSTR(*(I + (I[1]) + 0)));
  I += I[1] + 0;;
  DTRACE_LOCAL_CALL(c_p, erts_code_to_codemfa(I));
  Dispatch();;;
}

OpCase(move_call_xf):
{
  x(0) = xb(BeamExtraData(I[0]));
  SET_CP(c_p, I+2);
  ASSERT(VALID_INSTR(*(I + (I[1]) + 0)));
  I += I[1] + 0;;
  DTRACE_LOCAL_CALL(c_p, erts_code_to_codemfa(I));
  Dispatch();;
}

OpCase(move_call_yf):
{
  x(0) = yb(BeamExtraData(I[0]));
  SET_CP(c_p, I+2);
  ASSERT(VALID_INSTR(*(I + (I[1]) + 0)));
  I += I[1] + 0;;
  DTRACE_LOCAL_CALL(c_p, erts_code_to_codemfa(I));
  Dispatch();;
}

OpCase(move_cr):
{
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  r(0) = I[1];
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(move_cx):
{
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  xb(BeamExtraData(I[0])) = I[1];
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(move_cy):
{
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  yb(BeamExtraData(I[0])) = I[1];
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(move_deallocate_return_cQ):
{
  x(0) = I[1];
  do {
    int words_to_pop = Qb(BeamExtraData(I[0]));
    SET_I((BeamInstr *) cp_val(*E));
    E = ADD_BYTE_OFFSET(E, words_to_pop);
    CHECK_TERM(x(0));
    DispatchReturn;
  } while (0);
}

OpCase(move_deallocate_return_nQ):
{
  x(0) = NIL;
  do {
    int words_to_pop = Qb(BeamExtraData(I[0]));
    SET_I((BeamInstr *) cp_val(*E));
    E = ADD_BYTE_OFFSET(E, words_to_pop);
    CHECK_TERM(x(0));
    DispatchReturn;
  } while (0);
}

OpCase(move_deallocate_return_xQ):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  x(0) = xb(tmp_packed1&BEAM_TIGHT_MASK);
  do {
    int words_to_pop = Qb((tmp_packed1>>BEAM_TIGHT_SHIFT));
    SET_I((BeamInstr *) cp_val(*E));
    E = ADD_BYTE_OFFSET(E, words_to_pop);
    CHECK_TERM(x(0));
    DispatchReturn;
  } while (0);
}

OpCase(move_deallocate_return_yQ):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  x(0) = yb(tmp_packed1&BEAM_TIGHT_MASK);
  do {
    int words_to_pop = Qb((tmp_packed1>>BEAM_TIGHT_SHIFT));
    SET_I((BeamInstr *) cp_val(*E));
    E = ADD_BYTE_OFFSET(E, words_to_pop);
    CHECK_TERM(x(0));
    DispatchReturn;
  } while (0);
}

OpCase(move_jump_fcr):
{
  Eterm lbl = fb(BeamExtraData(I[0]));
  Eterm src = I[1];
  r(0) = src;
  ASSERT(VALID_INSTR(*(I + (lbl) + 0)));
  I += lbl + 0;;
  Goto(*I);;
}

OpCase(move_jump_fcx):
{
  Eterm lbl = fb(BeamExtraData(I[0]));
  Eterm src = I[1];
  xb(I[2]) = src;
  ASSERT(VALID_INSTR(*(I + (lbl) + 0)));
  I += lbl + 0;;
  Goto(*I);;
}

OpCase(move_jump_fcy):
{
  Eterm lbl = fb(BeamExtraData(I[0]));
  Eterm src = I[1];
  yb(I[2]) = src;
  ASSERT(VALID_INSTR(*(I + (lbl) + 0)));
  I += lbl + 0;;
  Goto(*I);;
}

OpCase(move_jump_fxx):
{
  Eterm tmp_packed2 = I[1];
  Eterm lbl = fb(BeamExtraData(I[0]));
  Eterm src = xb(tmp_packed2&BEAM_LOOSE_MASK);
  xb((tmp_packed2>>BEAM_LOOSE_SHIFT)) = src;
  ASSERT(VALID_INSTR(*(I + (lbl) + 0)));
  I += lbl + 0;;
  Goto(*I);;
}

OpCase(move_jump_fxy):
{
  Eterm tmp_packed2 = I[1];
  Eterm lbl = fb(BeamExtraData(I[0]));
  Eterm src = xb(tmp_packed2&BEAM_LOOSE_MASK);
  yb((tmp_packed2>>BEAM_LOOSE_SHIFT)) = src;
  ASSERT(VALID_INSTR(*(I + (lbl) + 0)));
  I += lbl + 0;;
  Goto(*I);;
}

OpCase(move_jump_fyx):
{
  Eterm tmp_packed2 = I[1];
  Eterm lbl = fb(BeamExtraData(I[0]));
  Eterm src = yb(tmp_packed2&BEAM_LOOSE_MASK);
  xb((tmp_packed2>>BEAM_LOOSE_SHIFT)) = src;
  ASSERT(VALID_INSTR(*(I + (lbl) + 0)));
  I += lbl + 0;;
  Goto(*I);;
}

OpCase(move_jump_fyy):
{
  Eterm tmp_packed2 = I[1];
  Eterm lbl = fb(BeamExtraData(I[0]));
  Eterm src = yb(tmp_packed2&BEAM_LOOSE_MASK);
  yb((tmp_packed2>>BEAM_LOOSE_SHIFT)) = src;
  ASSERT(VALID_INSTR(*(I + (lbl) + 0)));
  I += lbl + 0;;
  Goto(*I);;
}

OpCase(move_nx):
{
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  xb(BeamExtraData(I[0])) = NIL;
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(move_return_c):
{
  x(0) = I[1];
  SET_I(c_p->cp);
  c_p->cp = 0;
  DispatchReturn;
}

OpCase(move_return_n):
{
  x(0) = NIL;
  SET_I(c_p->cp);
  c_p->cp = 0;
  DispatchReturn;
}

OpCase(move_return_x):
{
  x(0) = xb(BeamExtraData(I[0]));
  SET_I(c_p->cp);
  c_p->cp = 0;
  DispatchReturn;
}

OpCase(move_rx):
{
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  xb(BeamExtraData(I[0])) = r(0);
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(move_ry):
{
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  yb(BeamExtraData(I[0])) = r(0);
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(move_shift_cxx):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  Eterm V;
  V = I[1];
  xb((tmp_packed1>>BEAM_TIGHT_SHIFT)) = xb(tmp_packed1&BEAM_TIGHT_MASK);
  xb(tmp_packed1&BEAM_TIGHT_MASK) = V;
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(move_shift_nyx):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  Eterm V;
  V = NIL;
  xb((tmp_packed1>>BEAM_TIGHT_SHIFT)) = yb(tmp_packed1&BEAM_TIGHT_MASK);
  yb(tmp_packed1&BEAM_TIGHT_MASK) = V;
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(move_shift_xxx):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  Eterm V;
  V = x(tmp_packed1&BEAM_TIGHTEST_MASK);
  x((tmp_packed1>>(2*BEAM_TIGHTEST_SHIFT))) = x((tmp_packed1>>BEAM_TIGHTEST_SHIFT)&BEAM_TIGHTEST_MASK);
  x((tmp_packed1>>BEAM_TIGHTEST_SHIFT)&BEAM_TIGHTEST_MASK) = V;
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(move_shift_xxy):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  Eterm V;
  V = x(tmp_packed1&BEAM_TIGHTEST_MASK);
  y((tmp_packed1>>(2*BEAM_TIGHTEST_SHIFT))) = x((tmp_packed1>>BEAM_TIGHTEST_SHIFT)&BEAM_TIGHTEST_MASK);
  x((tmp_packed1>>BEAM_TIGHTEST_SHIFT)&BEAM_TIGHTEST_MASK) = V;
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(move_shift_xyx):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  Eterm V;
  V = x(tmp_packed1&BEAM_TIGHTEST_MASK);
  x((tmp_packed1>>(2*BEAM_TIGHTEST_SHIFT))) = y((tmp_packed1>>BEAM_TIGHTEST_SHIFT)&BEAM_TIGHTEST_MASK);
  y((tmp_packed1>>BEAM_TIGHTEST_SHIFT)&BEAM_TIGHTEST_MASK) = V;
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(move_shift_yry):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  Eterm V;
  V = yb(tmp_packed1&BEAM_TIGHT_MASK);
  yb((tmp_packed1>>BEAM_TIGHT_SHIFT)) = r(0);
  r(0) = V;
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(move_shift_yxx):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  Eterm V;
  V = y(tmp_packed1&BEAM_TIGHTEST_MASK);
  x((tmp_packed1>>(2*BEAM_TIGHTEST_SHIFT))) = x((tmp_packed1>>BEAM_TIGHTEST_SHIFT)&BEAM_TIGHTEST_MASK);
  x((tmp_packed1>>BEAM_TIGHTEST_SHIFT)&BEAM_TIGHTEST_MASK) = V;
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(move_src_window2_yxx):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  Eterm* src = &y(tmp_packed1&BEAM_TIGHTEST_MASK);
  Eterm s1, s2;
  s1 = src[0];
  s2 = src[1];
  x((tmp_packed1>>BEAM_TIGHTEST_SHIFT)&BEAM_TIGHTEST_MASK) = s1;
  x((tmp_packed1>>(2*BEAM_TIGHTEST_SHIFT))) = s2;
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(move_src_window3_yxxx):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  Eterm* src = &yb(tmp_packed1&BEAM_LOOSE_MASK);
  Eterm s1, s2, s3;
  s1 = src[0];
  s2 = src[1];
  s3 = src[2];
  xb((tmp_packed1>>BEAM_LOOSE_SHIFT)&BEAM_LOOSE_MASK) = s1;
  xb((tmp_packed1>>(2*BEAM_LOOSE_SHIFT))&BEAM_LOOSE_MASK) = s2;
  xb((tmp_packed1>>(3*BEAM_LOOSE_SHIFT))) = s3;
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(move_src_window4_yxxxx):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  Eterm tmp_packed2 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  Eterm* src = &y(tmp_packed1&BEAM_TIGHTEST_MASK);
  Eterm s1, s2, s3, s4;
  s1 = src[0];
  s2 = src[1];
  s3 = src[2];
  s4 = src[3];
  x((tmp_packed1>>BEAM_TIGHTEST_SHIFT)&BEAM_TIGHTEST_MASK) = s1;
  x((tmp_packed1>>(2*BEAM_TIGHTEST_SHIFT))) = s2;
  xb(tmp_packed2&BEAM_LOOSE_MASK) = s3;
  xb((tmp_packed2>>BEAM_LOOSE_SHIFT)) = s4;
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(move_trim_yxt):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  Uint cp = E[0];
  xb((tmp_packed1>>BEAM_TIGHT_SHIFT)&BEAM_TIGHT_MASK) = yb(tmp_packed1&BEAM_TIGHT_MASK);
  E += tb((tmp_packed1>>(2*BEAM_TIGHT_SHIFT)));
  E[0] = cp;
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(move_window2_xxy):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  Eterm xt0, xt1;
  Eterm* y = &y((tmp_packed1>>(2*BEAM_TIGHTEST_SHIFT)));
  xt0  = x(tmp_packed1&BEAM_TIGHTEST_MASK);
  xt1  = x((tmp_packed1>>BEAM_TIGHTEST_SHIFT)&BEAM_TIGHTEST_MASK);
  y[0] = xt0;
  y[1] = xt1;
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(move_window3_xxxy):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  Eterm xt0, xt1, xt2;
  Eterm* y = &yb((tmp_packed1>>(3*BEAM_LOOSE_SHIFT)));
  xt0  = xb(tmp_packed1&BEAM_LOOSE_MASK);
  xt1  = xb((tmp_packed1>>BEAM_LOOSE_SHIFT)&BEAM_LOOSE_MASK);
  xt2  = xb((tmp_packed1>>(2*BEAM_LOOSE_SHIFT))&BEAM_LOOSE_MASK);
  y[0] = xt0;
  y[1] = xt1;
  y[2] = xt2;
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(move_window4_xxxxy):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  Eterm tmp_packed2 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  Eterm xt0, xt1, xt2, xt3;
  Eterm* y = &yb((tmp_packed2>>BEAM_LOOSE_SHIFT));
  xt0  = x(tmp_packed1&BEAM_TIGHTEST_MASK);
  xt1  = x((tmp_packed1>>BEAM_TIGHTEST_SHIFT)&BEAM_TIGHTEST_MASK);
  xt2  = x((tmp_packed1>>(2*BEAM_TIGHTEST_SHIFT)));
  xt3  = xb(tmp_packed2&BEAM_LOOSE_MASK);
  y[0] = xt0;
  y[1] = xt1;
  y[2] = xt2;
  y[3] = xt3;
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(move_window5_xxxxxy):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  Eterm tmp_packed2 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  Eterm xt0, xt1, xt2, xt3, xt4;
  Eterm *y = &yb((tmp_packed2>>(2*BEAM_TIGHT_SHIFT)));
  xt0  = x(tmp_packed1&BEAM_TIGHTEST_MASK);
  xt1  = x((tmp_packed1>>BEAM_TIGHTEST_SHIFT)&BEAM_TIGHTEST_MASK);
  xt2  = x((tmp_packed1>>(2*BEAM_TIGHTEST_SHIFT)));
  xt3  = xb(tmp_packed2&BEAM_TIGHT_MASK);
  xt4  = xb((tmp_packed2>>BEAM_TIGHT_SHIFT)&BEAM_TIGHT_MASK);
  y[0] = xt0;
  y[1] = xt1;
  y[2] = xt2;
  y[3] = xt3;
  y[4] = xt4;
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(move_x1_c):
{
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  x(1) = I[1];
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(move_x2_c):
{
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  x(2) = I[1];
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(move_xr):
{
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  r(0) = xb(BeamExtraData(I[0]));
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(move_xx):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  xb((tmp_packed1>>BEAM_TIGHT_SHIFT)) = xb(tmp_packed1&BEAM_TIGHT_MASK);
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(move_xy):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  yb((tmp_packed1>>BEAM_TIGHT_SHIFT)) = xb(tmp_packed1&BEAM_TIGHT_MASK);
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(move_yr):
{
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  r(0) = yb(BeamExtraData(I[0]));
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(move_yx):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  xb((tmp_packed1>>BEAM_TIGHT_SHIFT)) = yb(tmp_packed1&BEAM_TIGHT_MASK);
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(move_yy):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  yb((tmp_packed1>>BEAM_TIGHT_SHIFT)) = yb(tmp_packed1&BEAM_TIGHT_MASK);
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(new_map_dtI):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  Eterm dst = db(tmp_packed1&BEAM_TIGHT_MASK);
  Eterm* dst_ptr = REG_TARGET_PTR(dst);
  Eterm res;

  HEAVY_SWAPOUT;
  res = erts_gc_new_map(c_p, reg, tb((tmp_packed1>>BEAM_TIGHT_SHIFT)), I[1], I+2);
  HEAVY_SWAPIN;
  dst_ptr = REG_TARGET_PTR(dst);
  *dst_ptr = res;
  SET_I((BeamInstr *) I+2+I[1]);
  Goto(*I);;
}

OpCase(node_x):
{
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  xb(BeamExtraData(I[0])) = erts_this_node->sysname;
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(put_list_cxx):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  HTOP[0] = I[1];
  HTOP[1] = xb(tmp_packed1&BEAM_TIGHT_MASK);
  xb((tmp_packed1>>BEAM_TIGHT_SHIFT)) = make_list(HTOP);
  HTOP += 2;
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(put_list_cyx):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  HTOP[0] = I[1];
  HTOP[1] = yb(tmp_packed1&BEAM_TIGHT_MASK);
  xb((tmp_packed1>>BEAM_TIGHT_SHIFT)) = make_list(HTOP);
  HTOP += 2;
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(put_list_rnr):
{
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  HTOP[0] = r(0);
  HTOP[1] = NIL;
  r(0) = make_list(HTOP);
  HTOP += 2;
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(put_list_rnx):
{
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  HTOP[0] = r(0);
  HTOP[1] = NIL;
  xb(BeamExtraData(I[0])) = make_list(HTOP);
  HTOP += 2;
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(put_list_rxr):
{
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  HTOP[0] = r(0);
  HTOP[1] = xb(BeamExtraData(I[0]));
  r(0) = make_list(HTOP);
  HTOP += 2;
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(put_list_rxx):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  HTOP[0] = r(0);
  HTOP[1] = xb(tmp_packed1&BEAM_TIGHT_MASK);
  xb((tmp_packed1>>BEAM_TIGHT_SHIFT)) = make_list(HTOP);
  HTOP += 2;
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(put_list_xcx):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  HTOP[0] = xb(tmp_packed1&BEAM_TIGHT_MASK);
  HTOP[1] = I[1];
  xb((tmp_packed1>>BEAM_TIGHT_SHIFT)) = make_list(HTOP);
  HTOP += 2;
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(put_list_xnx):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  HTOP[0] = xb(tmp_packed1&BEAM_TIGHT_MASK);
  HTOP[1] = NIL;
  xb((tmp_packed1>>BEAM_TIGHT_SHIFT)) = make_list(HTOP);
  HTOP += 2;
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(put_list_xny):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  HTOP[0] = xb(tmp_packed1&BEAM_TIGHT_MASK);
  HTOP[1] = NIL;
  yb((tmp_packed1>>BEAM_TIGHT_SHIFT)) = make_list(HTOP);
  HTOP += 2;
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(put_list_xxr):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  HTOP[0] = xb(tmp_packed1&BEAM_TIGHT_MASK);
  HTOP[1] = xb((tmp_packed1>>BEAM_TIGHT_SHIFT));
  r(0) = make_list(HTOP);
  HTOP += 2;
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(put_list_xxx):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  HTOP[0] = x(tmp_packed1&BEAM_TIGHTEST_MASK);
  HTOP[1] = x((tmp_packed1>>BEAM_TIGHTEST_SHIFT)&BEAM_TIGHTEST_MASK);
  x((tmp_packed1>>(2*BEAM_TIGHTEST_SHIFT))) = make_list(HTOP);
  HTOP += 2;
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(put_list_xyx):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  HTOP[0] = x(tmp_packed1&BEAM_TIGHTEST_MASK);
  HTOP[1] = y((tmp_packed1>>BEAM_TIGHTEST_SHIFT)&BEAM_TIGHTEST_MASK);
  x((tmp_packed1>>(2*BEAM_TIGHTEST_SHIFT))) = make_list(HTOP);
  HTOP += 2;
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(put_list_ycx):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  HTOP[0] = yb(tmp_packed1&BEAM_TIGHT_MASK);
  HTOP[1] = I[1];
  xb((tmp_packed1>>BEAM_TIGHT_SHIFT)) = make_list(HTOP);
  HTOP += 2;
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(put_list_ynx):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  HTOP[0] = yb(tmp_packed1&BEAM_TIGHT_MASK);
  HTOP[1] = NIL;
  xb((tmp_packed1>>BEAM_TIGHT_SHIFT)) = make_list(HTOP);
  HTOP += 2;
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(put_list_yny):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  HTOP[0] = yb(tmp_packed1&BEAM_TIGHT_MASK);
  HTOP[1] = NIL;
  yb((tmp_packed1>>BEAM_TIGHT_SHIFT)) = make_list(HTOP);
  HTOP += 2;
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(put_list_yxx):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  HTOP[0] = y(tmp_packed1&BEAM_TIGHTEST_MASK);
  HTOP[1] = x((tmp_packed1>>BEAM_TIGHTEST_SHIFT)&BEAM_TIGHTEST_MASK);
  x((tmp_packed1>>(2*BEAM_TIGHTEST_SHIFT))) = make_list(HTOP);
  HTOP += 2;
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(put_list_yyx):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  HTOP[0] = y(tmp_packed1&BEAM_TIGHTEST_MASK);
  HTOP[1] = y((tmp_packed1>>BEAM_TIGHTEST_SHIFT)&BEAM_TIGHTEST_MASK);
  x((tmp_packed1>>(2*BEAM_TIGHTEST_SHIFT))) = make_list(HTOP);
  HTOP += 2;
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(put_tuple2_xI):
{
  Eterm tmp_packed1 = I[1];
  Eterm* hp = HTOP;
  Eterm arity = Ib((tmp_packed1>>BEAM_WIDE_SHIFT));

  /*
  * If operands are not packed (in the 32-bit VM),
  * is is not safe to use xb(tmp_packed1&BEAM_WIDE_MASK) directly after I
  * has been updated.
  */
  Eterm* dst_ptr = &(xb(tmp_packed1&BEAM_WIDE_MASK));

  ASSERT(arity != 0);
  *hp++ = make_arityval(arity);
  I = I+2;
  do {
    Eterm term = *I++;
    switch (loader_tag(term)) {
      case LOADER_X_REG:
      *hp++ = x(loader_x_reg_index(term));
      break;
      case LOADER_Y_REG:
      *hp++ = y(loader_y_reg_index(term));
      break;
      default:
      *hp++ = term;
      break;
    }
  } while (--arity != 0);
  *dst_ptr = make_tuple(HTOP);
  HTOP = hp;
  ASSERT(VALID_INSTR(* (Eterm *)I));
  Goto(*I);
}

OpCase(put_tuple2_yI):
{
  Eterm tmp_packed1 = I[1];
  Eterm* hp = HTOP;
  Eterm arity = Ib((tmp_packed1>>BEAM_WIDE_SHIFT));

  /*
  * If operands are not packed (in the 32-bit VM),
  * is is not safe to use yb(tmp_packed1&BEAM_WIDE_MASK) directly after I
  * has been updated.
  */
  Eterm* dst_ptr = &(yb(tmp_packed1&BEAM_WIDE_MASK));

  ASSERT(arity != 0);
  *hp++ = make_arityval(arity);
  I = I+2;
  do {
    Eterm term = *I++;
    switch (loader_tag(term)) {
      case LOADER_X_REG:
      *hp++ = x(loader_x_reg_index(term));
      break;
      case LOADER_Y_REG:
      *hp++ = y(loader_y_reg_index(term));
      break;
      default:
      *hp++ = term;
      break;
    }
  } while (--arity != 0);
  *dst_ptr = make_tuple(HTOP);
  HTOP = hp;
  ASSERT(VALID_INSTR(* (Eterm *)I));
  Goto(*I);
}

OpCase(raw_raise):
{
  Eterm class = x(0);
  Eterm value = x(1);
  Eterm stacktrace = x(2);
  Eterm* freason_ptr;

  /*
  * Note that the i_raise instruction will override c_p->freason
  * with the freason field stored inside the StackTrace struct in
  * ftrace. Therefore, we must take care to store the class both
  * inside the StackTrace struct and in c_p->freason (important if
  * the class is different from the class of the original
  * exception).
  */
  freason_ptr = get_freason_ptr_from_exc(stacktrace);

  if (class == am_error) {
    *freason_ptr = c_p->freason = EXC_ERROR & ~EXF_SAVETRACE;
    c_p->fvalue = value;
    c_p->ftrace = stacktrace;
    goto find_func_info;
  } else if (class == am_exit) {
    *freason_ptr = c_p->freason = EXC_EXIT & ~EXF_SAVETRACE;
    c_p->fvalue = value;
    c_p->ftrace = stacktrace;
    goto find_func_info;
  } else if (class == am_throw) {
    *freason_ptr = c_p->freason = EXC_THROWN & ~EXF_SAVETRACE;
    c_p->fvalue = value;
    c_p->ftrace = stacktrace;
    goto find_func_info;
  } else {
    x(0) = am_badarg;
  }
  I += 1;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(remove_message):
{

  /*
  * Remove a (matched) message from the message queue.
  */

  ErtsMessage* msgp;
  PROCESS_MAIN_CHK_LOCKS(c_p);

  ERTS_CHK_MBUF_SZ(c_p);

  msgp = PEEK_MESSAGE(c_p);

  if (ERTS_PROC_GET_SAVED_CALLS_BUF(c_p)) {
    save_calls(c_p, &exp_receive);
  }
  if (ERL_MESSAGE_TOKEN(msgp) == NIL) {
#ifdef USE_VM_PROBES
    if (DT_UTAG(c_p) != NIL) {
      if (DT_UTAG_FLAGS(c_p) & DT_UTAG_PERMANENT) {
        SEQ_TRACE_TOKEN(c_p) = am_have_dt_utag;
      } else {
        DT_UTAG(c_p) = NIL;
        SEQ_TRACE_TOKEN(c_p) = NIL;
      }
    } else {
#endif
      SEQ_TRACE_TOKEN(c_p) = NIL;
#ifdef USE_VM_PROBES
    }
    DT_UTAG_FLAGS(c_p) &= ~DT_UTAG_SPREADING;
#endif
  } else if (ERL_MESSAGE_TOKEN(msgp) != am_undefined) {
    Eterm msg;
    SEQ_TRACE_TOKEN(c_p) = ERL_MESSAGE_TOKEN(msgp);
#ifdef USE_VM_PROBES
    if (ERL_MESSAGE_TOKEN(msgp) == am_have_dt_utag) {
      if (DT_UTAG(c_p) == NIL) {
        DT_UTAG(c_p) = ERL_MESSAGE_DT_UTAG(msgp);
      }
      DT_UTAG_FLAGS(c_p) |= DT_UTAG_SPREADING;
    } else {
#endif
      ASSERT(is_tuple(SEQ_TRACE_TOKEN(c_p)));
      ASSERT(SEQ_TRACE_TOKEN_ARITY(c_p) == 5);
      ASSERT(is_small(SEQ_TRACE_TOKEN_SERIAL(c_p)));
      ASSERT(is_small(SEQ_TRACE_TOKEN_LASTCNT(c_p)));
      ASSERT(is_small(SEQ_TRACE_TOKEN_FLAGS(c_p)));
      ASSERT(is_pid(SEQ_TRACE_TOKEN_SENDER(c_p)));
      c_p->seq_trace_lastcnt = unsigned_val(SEQ_TRACE_TOKEN_SERIAL(c_p));
      if (c_p->seq_trace_clock < unsigned_val(SEQ_TRACE_TOKEN_SERIAL(c_p))) {
        c_p->seq_trace_clock = unsigned_val(SEQ_TRACE_TOKEN_SERIAL(c_p));
      }
      msg = ERL_MESSAGE_TERM(msgp);
      seq_trace_output(SEQ_TRACE_TOKEN(c_p), msg, SEQ_TRACE_RECEIVE, 
      c_p->common.id, c_p);
#ifdef USE_VM_PROBES
    }
#endif
  }
#ifdef USE_VM_PROBES
  if (DTRACE_ENABLED(message_receive)) {
    Eterm token2 = NIL;
    DTRACE_CHARBUF(receiver_name, DTRACE_TERM_BUF_SIZE);
    Sint tok_label = 0;
    Sint tok_lastcnt = 0;
    Sint tok_serial = 0;
    Sint len = erts_proc_sig_privqs_len(c_p);

    dtrace_proc_str(c_p, receiver_name);
    token2 = SEQ_TRACE_TOKEN(c_p);
    if (have_seqtrace(token2)) {
      tok_label = SEQ_TRACE_T_DTRACE_LABEL(token2);
      tok_lastcnt = signed_val(SEQ_TRACE_T_LASTCNT(token2));
      tok_serial = signed_val(SEQ_TRACE_T_SERIAL(token2));
    }
    DTRACE6(message_receive,
    receiver_name, size_object(ERL_MESSAGE_TERM(msgp)),
    len, /* This is NOT message queue len, but its something... */
    tok_label, tok_lastcnt, tok_serial);
  }
#endif
  UNLINK_MESSAGE(c_p, msgp);
  JOIN_MESSAGE(c_p);
  CANCEL_TIMER(c_p);

  erts_save_message_in_proc(c_p, msgp);
  c_p->flags &= ~F_DELAY_GC;

  if (ERTS_IS_GC_DESIRED_INTERNAL(c_p, HTOP, E)) {
    /*
    * We want to GC soon but we leave a few
    * reductions giving the message some time
    * to turn into garbage.
    */
    ERTS_VBUMP_LEAVE_REDS_INTERNAL(c_p, 5, FCALLS);
  }

  ERTS_DBG_CHK_REDS(c_p, FCALLS);
  ERTS_CHK_MBUF_SZ(c_p);

  ERTS_VERIFY_UNUSED_TEMP_ALLOC(c_p);
  PROCESS_MAIN_CHK_LOCKS(c_p);
  I += 1;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(return):
{
  SET_I(c_p->cp);
  DTRACE_RETURN_FROM_PC(c_p);

  /*
  * We must clear the CP to make sure that a stale value do not
  * create a false module dependcy preventing code upgrading.
  * It also means that we can use the CP in stack backtraces.
  */
  c_p->cp = 0;
  CHECK_TERM(r(0));
  HEAP_SPACE_VERIFIED(0);
  DispatchReturn;
}

OpCase(self_x):
{
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  xb(BeamExtraData(I[0])) = c_p->common.id;
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(self_y):
{
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  yb(BeamExtraData(I[0])) = c_p->common.id;
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(send):
{
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  Eterm result;

  if (!(FCALLS > 0 || FCALLS > neg_o_reds)) {
    /* If we have run out of reductions, we do a context
    switch before calling the bif */
    c_p->arity = 2;
    c_p->current = NULL;
    goto context_switch3;
  }

  PRE_BIF_SWAPOUT(c_p);
  c_p->fcalls = FCALLS - 1;
  result = erl_send(c_p, r(0), x(1));
  ERTS_VERIFY_UNUSED_TEMP_ALLOC(c_p);
  ERTS_REQ_PROC_MAIN_LOCK(c_p);
  PROCESS_MAIN_CHK_LOCKS(c_p);
  HTOP = HEAP_TOP(c_p);
  FCALLS = c_p->fcalls;
  if (ERTS_LIKELY(is_value(result))) {
    r(0) = result;
    CHECK_TERM(r(0));
  } else if (c_p->freason == TRAP) {
    SET_CP(c_p, I+1);
    SET_I(c_p->i);
    SWAPIN;
    Dispatch();
  } else {
    goto find_func_info;
  }
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(set_tuple_element_sSP):
{
  Eterm targ1;
  BeamInstr next_pf = BeamCodeAddr(I[3]);
  GetSource(I[1], targ1);
  {
    Eterm* p;

    ASSERT(is_tuple(Sb(BeamExtraData(I[0]))));
    p = (Eterm *) ((unsigned char *) tuple_val(Sb(BeamExtraData(I[0]))) + I[2]);
    *p = targ1;
    I += 3;
    ASSERT(VALID_INSTR(next_pf));
    GotoPF(next_pf);
  }
}

OpCase(swap_temp_xxx):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  Eterm V = x(tmp_packed1&BEAM_TIGHTEST_MASK);
  x(tmp_packed1&BEAM_TIGHTEST_MASK) = x((tmp_packed1>>BEAM_TIGHTEST_SHIFT)&BEAM_TIGHTEST_MASK);
  x((tmp_packed1>>BEAM_TIGHTEST_SHIFT)&BEAM_TIGHTEST_MASK) = x((tmp_packed1>>(2*BEAM_TIGHTEST_SHIFT))) = V;
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(swap_xx):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  Eterm V = xb(tmp_packed1&BEAM_TIGHT_MASK);
  xb(tmp_packed1&BEAM_TIGHT_MASK) = xb((tmp_packed1>>BEAM_TIGHT_SHIFT));
  xb((tmp_packed1>>BEAM_TIGHT_SHIFT)) = V;
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(swap_yx):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  Eterm V = yb(tmp_packed1&BEAM_TIGHT_MASK);
  yb(tmp_packed1&BEAM_TIGHT_MASK) = xb((tmp_packed1>>BEAM_TIGHT_SHIFT));
  xb((tmp_packed1>>BEAM_TIGHT_SHIFT)) = V;
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(swap_yy):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  Eterm V = yb(tmp_packed1&BEAM_TIGHT_MASK);
  yb(tmp_packed1&BEAM_TIGHT_MASK) = yb((tmp_packed1>>BEAM_TIGHT_SHIFT));
  yb((tmp_packed1>>BEAM_TIGHT_SHIFT)) = V;
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(test_arity_fxA):
{
  if (*tuple_val(xb(I[1])) != I[2]) {
    ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
    I += fb(BeamExtraData(I[0])) + 0;;
    Goto(*I);;
  }
  I += 3;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(test_arity_fyA):
{
  if (*tuple_val(yb(I[1])) != I[2]) {
    ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
    I += fb(BeamExtraData(I[0])) + 0;;
    Goto(*I);;
  }
  I += 3;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(test_arity_get_tuple_element_fxAPx):
{
  Eterm tmp_packed2 = I[1];
  Eterm* ptr = tuple_val(xb(tmp_packed2&BEAM_LOOSE_MASK));
  Eterm* src;
  if (*ptr != I[2]) {
    ASSERT(VALID_INSTR(*(I + (fb(BeamExtraData(I[0]))) + 0)));
    I += fb(BeamExtraData(I[0])) + 0;;
    Goto(*I);;
  }
  src = ADD_BYTE_OFFSET(ptr, I[3]);
  xb((tmp_packed2>>BEAM_LOOSE_SHIFT)) = *src;
  I += 4;
  ASSERT(VALID_INSTR(*I));
  Goto(*I);
}

OpCase(test_heap_1_put_list_Iy):
{
  Eterm tmp_packed1 = I[1];
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  do {
    Uint need = Ib(tmp_packed1&BEAM_WIDE_MASK) + 0;
    if (ERTS_UNLIKELY(E - HTOP < need)) {
      do {
        //
        // Since a garbage collection is expensive anyway, we can afford
        // to save the instruction counter so that the correct function will
        // be pointed in the crash dump if the garbage collection fails
        // because of insufficient memory.
        //
        SWAPOUT;
        c_p->i = I;
      } while (0);
      PROCESS_MAIN_CHK_LOCKS(c_p);
      FCALLS -= erts_garbage_collect_nobump(c_p, need, reg, 1, FCALLS);
      ERTS_VERIFY_UNUSED_TEMP_ALLOC(c_p);
      PROCESS_MAIN_CHK_LOCKS(c_p);
      SWAPIN;
    }
    HEAP_SPACE_VERIFIED(Ib(tmp_packed1&BEAM_WIDE_MASK));
  } while (0);;
  do {
    HTOP[0] = yb((tmp_packed1>>BEAM_WIDE_SHIFT));
    HTOP[1] = x(0);
    x(0) = make_list(HTOP);
    HTOP += 2;
  } while (0);
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(test_heap_It):
{
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  do {
    Uint need = I[1] + 0;
    if (ERTS_UNLIKELY(E - HTOP < need)) {
      do {
        //
        // Since a garbage collection is expensive anyway, we can afford
        // to save the instruction counter so that the correct function will
        // be pointed in the crash dump if the garbage collection fails
        // because of insufficient memory.
        //
        SWAPOUT;
        c_p->i = I;
      } while (0);
      PROCESS_MAIN_CHK_LOCKS(c_p);
      FCALLS -= erts_garbage_collect_nobump(c_p, need, reg, tb(BeamExtraData(I[0])), FCALLS);
      ERTS_VERIFY_UNUSED_TEMP_ALLOC(c_p);
      PROCESS_MAIN_CHK_LOCKS(c_p);
      SWAPIN;
    }
    HEAP_SPACE_VERIFIED(I[1]);
  } while (0);
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(timeout):
{
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  if (IS_TRACED_FL(c_p, F_TRACE_RECEIVE)) {
    trace_receive(c_p, am_clock_service, am_timeout, NULL);
  }
  if (ERTS_PROC_GET_SAVED_CALLS_BUF(c_p)) {
    save_calls(c_p, &exp_timeout);
  }
  c_p->flags &= ~F_TIMO;
  JOIN_MESSAGE(c_p);
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(timeout_locked):
{
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  /*
  * A timeout has occurred.  Reset the save pointer so that the next
  * receive statement will examine the first message first.
  */

  erts_proc_unlock(c_p, ERTS_PROC_LOCKS_MSG_RECEIVE);
  if (IS_TRACED_FL(c_p, F_TRACE_RECEIVE)) {
    trace_receive(c_p, am_clock_service, am_timeout, NULL);
  }
  if (ERTS_PROC_GET_SAVED_CALLS_BUF(c_p)) {
    save_calls(c_p, &exp_timeout);
  }
  c_p->flags &= ~F_TIMO;
  JOIN_MESSAGE(c_p);;
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(try_case_y):
{
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  c_p->catches--;
  make_blank(yb(BeamExtraData(I[0])));;
  ASSERT(is_non_value(r(0)));
  c_p->fvalue = NIL;
  r(0) = x(1);
  x(1) = x(2);
  x(2) = x(3);
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(try_end_y):
{
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  c_p->catches--;
  make_blank(yb(BeamExtraData(I[0])));
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(update_list_cx):
{
  BeamInstr next_pf = BeamCodeAddr(I[2]);
  HTOP[0] = I[1];
  HTOP[1] = xb(BeamExtraData(I[0]));
  xb(BeamExtraData(I[0])) = make_list(HTOP);
  HTOP += 2;
  I += 2;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(update_list_xx):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  HTOP[0] = xb(tmp_packed1&BEAM_TIGHT_MASK);
  HTOP[1] = xb((tmp_packed1>>BEAM_TIGHT_SHIFT));
  xb((tmp_packed1>>BEAM_TIGHT_SHIFT)) = make_list(HTOP);
  HTOP += 2;
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

OpCase(update_list_yx):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  BeamInstr next_pf = BeamCodeAddr(I[1]);
  HTOP[0] = yb(tmp_packed1&BEAM_TIGHT_MASK);
  HTOP[1] = xb((tmp_packed1>>BEAM_TIGHT_SHIFT));
  xb((tmp_packed1>>BEAM_TIGHT_SHIFT)) = make_list(HTOP);
  HTOP += 2;
  I += 1;
  ASSERT(VALID_INSTR(next_pf));
  GotoPF(next_pf);
}

{
  Eterm map;
  OpCase(update_map_assoc_cdtI):
  {
    map = I[1];
  }
  I += 1;
  goto update_map_assoc__execute;

  OpCase(update_map_assoc_xdtI):
  {
    map = xb(BeamExtraData(I[0]));
  }
  goto update_map_assoc__execute;

  OpCase(update_map_assoc_ydtI):
  {
    map = yb(BeamExtraData(I[0]));
  }
  goto update_map_assoc__execute;

  update_map_assoc__execute:
  {
    Eterm tmp_packed1 = I[1];
    Eterm dst = db(tmp_packed1&BEAM_LOOSE_MASK);
    Eterm* dst_ptr = REG_TARGET_PTR(dst);
    Eterm res;
    Uint live = tb((tmp_packed1>>BEAM_LOOSE_SHIFT));

    reg[live] = map;
    HEAVY_SWAPOUT;
    res = erts_gc_update_map_assoc(c_p, reg, live, I[2], I+3);
    HEAVY_SWAPIN;
    ASSERT(is_value(res));
    dst_ptr = REG_TARGET_PTR(dst);
    *dst_ptr = res;
    SET_I((BeamInstr *) I+3+I[2]);
    Goto(*I);;
  }

}

{
  Eterm map;
  OpCase(update_map_exact_xjdtI):
  {
    map = xb(BeamExtraData(I[0]));
  }
  goto update_map_exact__execute;

  OpCase(update_map_exact_yjdtI):
  {
    map = yb(BeamExtraData(I[0]));
  }
  goto update_map_exact__execute;

  update_map_exact__execute:
  {
    Eterm tmp_packed1 = I[1];
    Eterm tmp_packed2 = I[2];
    Eterm dst = db((tmp_packed1>>BEAM_WIDE_SHIFT));
    Eterm* dst_ptr = REG_TARGET_PTR(dst);
    Eterm res;
    Uint live = tb(tmp_packed2&BEAM_WIDE_MASK);

    reg[live] = map;
    HEAVY_SWAPOUT;
    res = erts_gc_update_map_exact(c_p, reg, live, Ib((tmp_packed2>>BEAM_WIDE_SHIFT)), I+3);
    HEAVY_SWAPIN;
    if (is_value(res)) {
      dst_ptr = REG_TARGET_PTR(dst);
      *dst_ptr = res;
      SET_I((BeamInstr *) I+3+Ib((tmp_packed2>>BEAM_WIDE_SHIFT)));
      Goto(*I);;
    } else {

      /*
      * In a correctly working program, we expect failures in
      * guards to be more likely than failures in bodies.
      */

      if (ERTS_LIKELY(jb(tmp_packed1&BEAM_WIDE_MASK))) {
        ASSERT(VALID_INSTR(*(I + (jb(tmp_packed1&BEAM_WIDE_MASK)) + 0)));
        I += jb(tmp_packed1&BEAM_WIDE_MASK) + 0;;
        Goto(*I);;
      }
      goto find_func_info;;
    }
  }

}

{
  OpCase(wait_locked_f):
  {

  }
  goto wait__execute;

  OpCase(wait_timeout_unlocked_int_If):
  {
    erts_proc_lock(c_p, ERTS_PROC_LOCKS_MSG_RECEIVE);
  }
  goto wait__int;

  OpCase(wait_timeout_unlocked_sf):
  {
    erts_proc_lock(c_p, ERTS_PROC_LOCKS_MSG_RECEIVE);
  }
  goto wait__src;

  OpCase(wait_unlocked_f):
  {
    erts_proc_lock(c_p, ERTS_PROC_LOCKS_MSG_RECEIVE);
  }
  goto wait__execute;

  OpCase(wait_timeout_locked_int_If):
  wait__int:
  {
    /*
    * If we have already set the timer, we must NOT set it again.  Therefore,
    * we must test the F_INSLPQUEUE flag as well as the F_TIMO flag.
    */
    if ((c_p->flags & (F_INSLPQUEUE | F_TIMO)) == 0) {
      BeamInstr** pi = (BeamInstr **) c_p->def_arg_reg;
      *pi = I+3;
      erts_set_proc_timer_uword(c_p, I[1]);
    }
  }
  I += 1;
  goto wait__execute;

  OpCase(wait_timeout_locked_sf):
  wait__src:
  {
    Eterm targ1;
    GetSource(I[1], targ1);
    {
      /*
      * If we have already set the timer, we must NOT set it again.  Therefore,
      * we must test the F_INSLPQUEUE flag as well as the F_TIMO flag.
      */
      if ((c_p->flags & (F_INSLPQUEUE | F_TIMO)) == 0) {
        Eterm timeout_value = targ1;
        if (timeout_value == make_small(0)) {
          erts_proc_unlock(c_p, ERTS_PROC_LOCKS_MSG_RECEIVE);
          SET_I((BeamInstr *) I+3);
          Goto(*I);;
        } else if (timeout_value == am_infinity) {
          c_p->flags |= F_TIMO;
        } else {
          int tres = erts_set_proc_timer_term(c_p, timeout_value);
          if (tres == 0) {
            /*
            * The timer routiner will set c_p->i to the value in
            * c_p->def_arg_reg[0].  Note that it is safe to use this
            * location because there are no living x registers in
            * a receive statement.
            */
            BeamInstr** pi = (BeamInstr**) c_p->def_arg_reg;
            *pi = I+3;
          } else { /* Wrong time */
            erts_proc_unlock(c_p, ERTS_PROC_LOCKS_MSG_RECEIVE);
            c_p->freason = EXC_TIMEOUT_VALUE;
            goto find_func_info;
          }
        }
      }
    }
  }
  I += 1;
  goto wait__execute;

  wait__execute:
  {
    c_p->i = I + (I[1]);
    ASSERT(VALID_INSTR(*c_p->i));; /* L1 */
    SWAPOUT;
    c_p->arity = 0;

    if (!ERTS_PTMR_IS_TIMED_OUT(c_p)) {
      erts_atomic32_read_band_relb(&c_p->state,
      ~ERTS_PSFLG_ACTIVE);
    }
    ASSERT(!ERTS_PROC_IS_EXITING(c_p));
    erts_proc_unlock(c_p, ERTS_PROC_LOCKS_MSG_RECEIVE);
    c_p->current = NULL;
    goto do_schedule;

  }

}

